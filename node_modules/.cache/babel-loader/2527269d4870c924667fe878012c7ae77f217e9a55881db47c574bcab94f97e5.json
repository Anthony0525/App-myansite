{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport { parseQuery, createRouter as createRouter$1, createWebHistory as createWebHistory$1, createWebHashHistory as createWebHashHistory$1, createMemoryHistory as createMemoryHistory$1 } from 'vue-router';\nimport { shallowRef } from 'vue';\nconst createLocationHistory = () => {\n  const locationHistory = [];\n  const tabsHistory = {};\n  const add = routeInfo => {\n    switch (routeInfo.routerAction) {\n      case \"pop\":\n        pop(routeInfo);\n        break;\n      default:\n        addRoute(routeInfo);\n        break;\n    }\n    if (routeInfo.routerDirection === \"root\") {\n      clearHistory();\n      addRoute(routeInfo);\n    }\n  };\n  const update = routeInfo => {\n    const locationIndex = locationHistory.findIndex(x => x.id === routeInfo.id);\n    if (locationIndex > -1) {\n      locationHistory.splice(locationIndex, 1, routeInfo);\n    }\n    const tabArray = tabsHistory[routeInfo.tab || \"\"];\n    if (tabArray) {\n      const tabIndex = tabArray.findIndex(x => x.id === routeInfo.id);\n      if (tabIndex > -1) {\n        tabArray.splice(tabIndex, 1, routeInfo);\n      } else {\n        tabArray.push(routeInfo);\n      }\n    } else if (routeInfo.tab) {\n      tabsHistory[routeInfo.tab] = [routeInfo];\n    }\n  };\n  const pop = routeInfo => {\n    const tabHistory = getTabsHistory(routeInfo.tab);\n    let ri;\n    if (tabHistory) {\n      // Pop all routes until we are back\n      ri = tabHistory[tabHistory.length - 1];\n      while (ri && ri.id !== routeInfo.id) {\n        tabHistory.pop();\n        ri = tabHistory[tabHistory.length - 1];\n      }\n      // Replace with updated route\n      tabHistory.pop();\n      tabHistory.push(routeInfo);\n    }\n    ri = locationHistory[locationHistory.length - 1];\n    while (ri && ri.id !== routeInfo.id) {\n      locationHistory.pop();\n      ri = locationHistory[locationHistory.length - 1];\n    }\n    // Replace with updated route\n    locationHistory.pop();\n    locationHistory.push(routeInfo);\n  };\n  const addRoute = routeInfo => {\n    const tabHistory = getTabsHistory(routeInfo.tab);\n    if (tabHistory) {\n      // If the latest routeInfo is the same (going back and forth between tabs), replace it\n      if (tabHistory[tabHistory.length - 1] && tabHistory[tabHistory.length - 1].id === routeInfo.id) {\n        tabHistory.pop();\n      }\n      tabHistory.push(routeInfo);\n    }\n    locationHistory.push(routeInfo);\n  };\n  /**\n   * Wipes the location history arrays.\n   * You can optionally provide a routeInfo\n   * object which will wipe that entry\n   * and every entry that appears after it.\n   */\n  const clearHistory = routeInfo => {\n    if (routeInfo) {\n      const {\n        position,\n        tab\n      } = routeInfo;\n      /**\n       * If there is no route index in locationHistory\n       * then there will not be any route index in\n       * tabs either.\n       */\n      const existingRouteIndex = locationHistory.findIndex(r => r.position === position);\n      if (existingRouteIndex === -1) return;\n      locationHistory.splice(existingRouteIndex);\n      const clearTabHistory = tab => {\n        const existingTabRouteIndex = tabsHistory[tab].findIndex(r => r.position === position);\n        if (existingTabRouteIndex === -1) return;\n        tabsHistory[tab].splice(existingTabRouteIndex);\n      };\n      /**\n       * We also need to search the current tab\n       * to correctly reset the individual tab\n       * stack. We should not clear the entire\n       * tab stack as that means we will lose\n       * a reference to the root tab route.\n       */\n      const tabHistory = tabsHistory[tab];\n      if (tab && tabHistory) {\n        clearTabHistory(tab);\n        /**\n         * If we are not clearing items after\n         * a tabs page, it is still possible\n         * that there are future tabs pages to clear.\n         * As a result, we need to search through\n         * all the tab stacks and remove views that appear\n         * after the given routeInfo.\n         *\n         * Example: /non-tabs-page --> /tabs/tab1 --> /non-tabs-page\n         * (via router.go(-1)) --> /tabs/tab2. The /tabs/tab1 history\n         * has been overwritten with /tabs/tab2. As a result,\n         * the /tabs/tab1 route info in the Tab 1 stack should be removed.\n         */\n      } else {\n        for (const tab in tabsHistory) {\n          clearTabHistory(tab);\n        }\n      }\n    } else {\n      for (const tab in tabsHistory) {\n        tabsHistory[tab] = [];\n      }\n      locationHistory.length = 0;\n    }\n  };\n  const getTabsHistory = tab => {\n    let history;\n    if (tab) {\n      history = tabsHistory[tab];\n      if (!history) {\n        history = tabsHistory[tab] = [];\n      }\n    }\n    return history;\n  };\n  const size = () => locationHistory.length;\n  /**\n   * Finds and returns the location history item\n   * given the state of browser's history API.\n   * This is useful when jumping around in browser\n   * history using router.go.\n   */\n  const current = (initialHistory, currentHistory) => {\n    /**\n     * initialHistory does not always start at 0 if users navigated\n     * to app from another website, so doing this math lets us\n     * find the correct index in our locationHistory array.\n     */\n    const index = currentHistory - initialHistory;\n    return locationHistory[index] || last();\n  };\n  const last = () => locationHistory[locationHistory.length - 1];\n  /**\n   * With the introduction of router.go support, we no longer remove\n   * items from locationHistory as they may be needed again in the future.\n   * As a result, we need to look at the current position in location history\n   * to see if users can navigate back n pages. Previously we were checking\n   * the length of locationHistory, but that only worked since we were pruning\n   * the array.\n   */\n  const canGoBack = (deep = 1, initialHistory, currentHistory) => {\n    return currentHistory - deep >= initialHistory;\n  };\n  const getFirstRouteInfoForTab = tab => {\n    const tabHistory = getTabsHistory(tab);\n    if (tabHistory) {\n      return tabHistory[0];\n    }\n    return undefined;\n  };\n  const getCurrentRouteInfoForTab = tab => {\n    const tabHistory = getTabsHistory(tab);\n    if (tabHistory) {\n      return tabHistory[tabHistory.length - 1];\n    }\n    return undefined;\n  };\n  /**\n   * Finds and returns the previous view based upon\n   * what originally pushed it (pushedByRoute).\n   * When `delta` < -1 then we should just index into\n   * to array because the previous view that we want is not\n   * necessarily the view that pushed our current view.\n   * Additionally, when jumping around in history, we\n   * do not modify the locationHistory stack so we would\n   * not update pushedByRoute anyways.\n   */\n  const findLastLocation = (routeInfo, delta = -1) => {\n    const routeInfos = getTabsHistory(routeInfo.tab);\n    if (routeInfos) {\n      if (delta < -1) {\n        return routeInfos[routeInfos.length - 1 + delta];\n      } else {\n        for (let i = routeInfos.length - 2; i >= 0; i--) {\n          const ri = routeInfos[i];\n          if (ri) {\n            if (ri.pathname === routeInfo.pushedByRoute) {\n              return ri;\n            }\n          }\n        }\n      }\n    }\n    for (let i = locationHistory.length - 2; i >= 0; i--) {\n      const ri = locationHistory[i];\n      if (ri) {\n        if (ri.pathname === routeInfo.pushedByRoute) {\n          return locationHistory[i + 1 + delta];\n        }\n      }\n    }\n    return undefined;\n  };\n  return {\n    current,\n    size,\n    last,\n    add,\n    canGoBack,\n    update,\n    getFirstRouteInfoForTab,\n    getCurrentRouteInfoForTab,\n    findLastLocation,\n    clearHistory\n  };\n};\nconst ids = {\n  main: 0\n};\nconst generateId = (type = \"main\") => {\n  var _a;\n  const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;\n  ids[type] = id;\n  return id.toString();\n};\n\n// TODO(FW-2969): types\nconst createIonRouter = (opts, router) => {\n  let currentNavigationInfo = {\n    direction: undefined,\n    action: undefined,\n    delta: undefined\n  };\n  /**\n   * Ionic Vue should only react to navigation\n   * changes once they have been confirmed and should\n   * never affect the outcome of navigation (with the\n   * exception of going back or selecting a tab).\n   * As a result, we should do our work in afterEach\n   * which is fired once navigation is confirmed\n   * and any user guards have run.\n   */\n  router.afterEach((to, _, failure) => {\n    if (failure) return;\n    const {\n      direction,\n      action,\n      delta\n    } = currentNavigationInfo;\n    /**\n     * When calling router.replace, we are not informed\n     * about the replace action in opts.history.listen\n     * but we can check to see if the latest routing action\n     * was a replace action by looking at the history state.\n     * We need to use opts.history rather than window.history\n     * because window.history will be undefined when using SSR.\n     */\n    currentHistoryPosition = opts.history.state.position;\n    const replaceAction = opts.history.state.replaced ? \"replace\" : undefined;\n    handleHistoryChange(to, action || replaceAction, direction, delta);\n    currentNavigationInfo = {\n      direction: undefined,\n      action: undefined,\n      delta: undefined\n    };\n  });\n  const locationHistory = createLocationHistory();\n  /**\n   * Keeping track of the history position\n   * allows us to determine if a user is pushing\n   * new pages or updating history via the forward\n   * and back browser buttons.\n   */\n  let initialHistoryPosition = opts.history.state.position;\n  let currentHistoryPosition = opts.history.state.position;\n  let currentRouteInfo;\n  let incomingRouteParams;\n  const historyChangeListeners = [];\n  if (typeof document !== \"undefined\") {\n    document.addEventListener(\"ionBackButton\", ev => {\n      ev.detail.register(0, processNextHandler => {\n        opts.history.go(-1);\n        processNextHandler();\n      });\n    });\n  }\n  opts.history.listen((_, _x, info) => {\n    /**\n     * history.listen only fires on certain\n     * event such as when the user clicks the\n     * browser back button. It also gives us\n     * additional information as to the type\n     * of navigation (forward, backward, etc).\n     *\n     * We can use this to better handle the\n     * `handleHistoryChange` call in\n     * router.beforeEach\n     */\n    currentNavigationInfo = {\n      delta: info.delta,\n      /**\n       * Both the browser forward and backward actions\n       * are considered \"pop\" actions, but when going forward\n       * we want to make sure the forward animation is used.\n       */\n      action: info.type === \"pop\" && info.delta >= 1 ? \"push\" : info.type,\n      direction: info.direction === \"\" ? \"forward\" : info.direction\n    };\n  });\n  const handleNavigateBack = (defaultHref, routerAnimation) => {\n    const routeInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition);\n    if (routeInfo && routeInfo.pushedByRoute) {\n      const prevInfo = locationHistory.findLastLocation(routeInfo);\n      if (prevInfo) {\n        incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n          routerAction: \"pop\",\n          routerDirection: \"back\",\n          routerAnimation: routerAnimation || routeInfo.routerAnimation\n        });\n        if (routeInfo.lastPathname === routeInfo.pushedByRoute || (\n        /**\n         * We need to exclude tab switches/tab\n         * context changes here because tabbed\n         * navigation is not linear, but router.back()\n         * will go back in a linear fashion.\n         */\n        prevInfo.pathname === routeInfo.pushedByRoute &&\n        /**\n         * Tab info can be undefined or '' (empty string)\n         * both are false-y values, so we can just use !.\n         */\n        !routeInfo.tab && !prevInfo.tab)) {\n          router.back();\n        } else {\n          /**\n           * When going back to a child page of a tab\n           * after being on another tab, we need to use\n           * router.go() here instead of pushing or replacing.\n           * Consider the following example:\n           * /tabs/tab1 --> /tabs/tab1/child1 --> /tabs/tab1/child2\n           * --> /tabs/tab2 (via Tab 2 button) --> /tabs/tab1/child2 (via Tab 1 button)\n           *\n           * Pressing the ion-back-button on /tabs/tab1/child2 should take\n           * us back to /tabs/tab1/child1 not /tabs/tab2 because each tab\n           * is its own stack.\n           *\n           * If we called pressed the ion-back-button and this code called\n           * router.replace, then the state of /tabs/tab1/child2 would\n           * be replaced with /tabs/tab1/child1. However, this means that\n           * there would be two /tabs/tab1/child1 entries in the location\n           * history as the original /tabs/tab1/child1 entry is still there.\n           * As a result, clicking the ion-back-button on /tabs/tab1/child1 does\n           * nothing because this code would try to route to the same page\n           * we are currently on.\n           *\n           * If we called router.push instead then we would push a\n           * new /tabs/tab1/child1 entry to the location history. This\n           * is not good because we would have two /tabs/tab1/child1 entries\n           * separated by a /tabs/tab1/child2 entry.\n           */\n          router.go(prevInfo.position - routeInfo.position);\n        }\n      } else {\n        handleNavigate(defaultHref, \"pop\", \"back\", routerAnimation);\n      }\n    } else {\n      handleNavigate(defaultHref, \"pop\", \"back\", routerAnimation);\n    }\n  };\n  const handleNavigate = (path, routerAction, routerDirection, routerAnimation, tab) => {\n    setIncomingRouteParams(routerAction, routerDirection, routerAnimation, tab);\n    if (routerAction === \"push\") {\n      router.push(path);\n    } else {\n      router.replace(path);\n    }\n  };\n  // TODO RouteLocationNormalized\n  const handleHistoryChange = (location, action, direction, delta) => {\n    let leavingLocationInfo;\n    if (incomingRouteParams) {\n      /**\n       * If we are replacing the state of a route\n       * with another route, the \"leaving\" route\n       * is at the same position in location history\n       * as where the replaced route will exist.\n       */\n      if (incomingRouteParams.routerAction === \"replace\") {\n        leavingLocationInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition);\n      } else if (incomingRouteParams.routerAction === \"pop\") {\n        leavingLocationInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition + 1);\n        /**\n         * If the Ionic Router action was \"pop\"\n         * and the browser history action was \"replace\", then\n         * it is the case that the user clicked an IonBackButton\n         * that is trying to go back to the route specified\n         * by the defaultHref property.\n         *\n         * The problem is that this route currently does\n         * not exist in the browser history, and we cannot\n         * prepend an item in the browser's history stack.\n         * To work around this, we replace the state of\n         * the current item instead.\n         * Given this scenario:\n         * /page2 --> /page3 --> (back) /page2 --> (defaultHref) /page1\n         * We would replace the state of /page2 with the state of /page1.\n         *\n         * When doing this, we are essentially re-writing past\n         * history which makes the future history no longer relevant.\n         * As a result, we clear out the location history so that users\n         * can begin pushing new routes to the stack.\n         *\n         * This pattern is aligned with how the browser handles\n         * pushing new routes after going back as well as how\n         * other stack based operations such as undo/redo work.\n         * For example, if you do tasks A, B, C, undo B and C, and\n         * then do task D, you cannot \"redo\" B and C because you\n         * rewrote the stack's past history.\n         *\n         * With browser history, it is a similar concept.\n         * Going /page1 --> /page2 --> /page3 and then doing\n         * router.go(-2) will bring you back to /page1.\n         * If you then push /page4, you have rewritten\n         * the past history and you can no longer go\n         * forward to /page2 or /page3.\n         */\n        if (action === \"replace\") {\n          locationHistory.clearHistory();\n        }\n      } else {\n        /**\n         * If the routerDirection was specified as \"root\", then\n         * we are replacing the initial state of location history\n         * with this incoming route. As a result, the leaving\n         * history info is stored at the same location as\n         * where the incoming history location will be stored.\n         *\n         * Otherwise, we can assume this is just another route\n         * that will be pushed onto the end of location history,\n         * so we can grab the previous item in history relative\n         * to where the history state currently is.\n         */\n        const position = incomingRouteParams.routerDirection === \"root\" ? currentHistoryPosition : currentHistoryPosition - 1;\n        leavingLocationInfo = locationHistory.current(initialHistoryPosition, position);\n      }\n    } else {\n      leavingLocationInfo = currentRouteInfo;\n    }\n    if (!leavingLocationInfo) {\n      leavingLocationInfo = {\n        pathname: \"\",\n        search: \"\"\n      };\n    }\n    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n    if (leavingUrl !== location.fullPath) {\n      if (!incomingRouteParams) {\n        if (action === \"replace\") {\n          incomingRouteParams = {\n            routerAction: \"replace\",\n            routerDirection: \"none\"\n          };\n        } else if (action === \"pop\") {\n          const routeInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition - delta);\n          if (routeInfo && routeInfo.pushedByRoute) {\n            const prevRouteInfo = locationHistory.findLastLocation(routeInfo, delta);\n            incomingRouteParams = Object.assign(Object.assign({}, prevRouteInfo), {\n              routerAction: \"pop\",\n              routerDirection: \"back\"\n            });\n          } else {\n            incomingRouteParams = {\n              routerAction: \"pop\",\n              routerDirection: \"none\"\n            };\n          }\n        }\n        if (!incomingRouteParams) {\n          incomingRouteParams = {\n            routerAction: \"push\",\n            routerDirection: direction || \"forward\"\n          };\n        }\n      }\n      let routeInfo;\n      if (incomingRouteParams === null || incomingRouteParams === void 0 ? void 0 : incomingRouteParams.id) {\n        routeInfo = Object.assign(Object.assign({}, incomingRouteParams), {\n          lastPathname: leavingLocationInfo.pathname\n        });\n      } else {\n        const isPushed = incomingRouteParams.routerAction === \"push\" && incomingRouteParams.routerDirection === \"forward\";\n        routeInfo = Object.assign(Object.assign({\n          id: generateId(\"routeInfo\")\n        }, incomingRouteParams), {\n          lastPathname: leavingLocationInfo.pathname,\n          pathname: location.path,\n          search: location.fullPath && location.fullPath.split(\"?\")[1] || \"\",\n          params: location.params && location.params,\n          prevRouteLastPathname: leavingLocationInfo.lastPathname\n        });\n        if (isPushed) {\n          routeInfo.pushedByRoute = leavingLocationInfo.pathname !== \"\" ? leavingLocationInfo.pathname : undefined;\n        } else if (routeInfo.routerAction === \"pop\") {\n          const route = locationHistory.findLastLocation(routeInfo);\n          routeInfo.pushedByRoute = route === null || route === void 0 ? void 0 : route.pushedByRoute;\n        } else if (routeInfo.routerAction === \"push\" && routeInfo.tab !== leavingLocationInfo.tab) {\n          const lastRoute = locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n          routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;\n        } else if (routeInfo.routerAction === \"replace\") {\n          /**\n           * When replacing a route, we want to make sure we select the current route\n           * that we are on, not the last route in the stack. The last route in the stack\n           * is not always the current route.\n           * Example:\n           * Given the following history: /page1 --> /page2\n           * Doing router.go(-1) would bring you to /page1.\n           * If you then did router.replace('/page3'), /page1 should\n           * be replaced with /page3 even though /page2 is the last\n           * item in the stack/\n           */\n          const currentRouteInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition);\n          /**\n           * If going from /home to /child, then replacing from\n           * /child to /home, we don't want the route info to\n           * say that /home was pushed by /home which is not correct.\n           */\n          const currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;\n          const pushedByRoute = currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname ? currentPushedBy : routeInfo.pushedByRoute;\n          routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;\n          routeInfo.pushedByRoute = pushedByRoute;\n          routeInfo.routerDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerDirection) || routeInfo.routerDirection;\n          routeInfo.routerAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerAnimation) || routeInfo.routerAnimation;\n          routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;\n        }\n      }\n      routeInfo.position = currentHistoryPosition;\n      routeInfo.delta = delta;\n      const historySize = locationHistory.size();\n      const historyDiff = currentHistoryPosition - initialHistoryPosition;\n      /**\n       * If the size of location history is greater\n       * than the difference between the current history\n       * position and the initial history position\n       * then we are guaranteed to already have a history\n       * item for this route. In other words, a user\n       * is navigating within the history without pushing\n       * new items within the stack.\n       *\n       * If the historySize === historyDiff,\n       * then we are still re-writing history\n       * by replacing the current route state\n       * with a new route state. The initial\n       * action when loading an app is\n       * going to be replace operation, so\n       * we want to make sure we exclude that\n       * action by ensuring historySize > 0.\n       */\n      const isReplacing = historySize === historyDiff && historySize > 0 && action === \"replace\";\n      if (historySize > historyDiff || isReplacing) {\n        /**\n         * When navigating back through the history,\n         * if users then push a new route the future\n         * history stack is no longer relevant. As\n         * a result, we need to clear out all entries\n         * that appear after the current routeInfo\n         * so that we can then append the new history.\n         *\n         * This does not apply when using router.go\n         * as that is traversing through the history,\n         * not altering it.\n         *\n         * Previously we had only updated the existing route\n         * and then left the future history alone. That\n         * worked for some use cases but was not sufficient\n         * in other scenarios.\n         */\n        if ((routeInfo.routerAction === \"push\" || routeInfo.routerAction === \"replace\") && delta === undefined) {\n          locationHistory.clearHistory(routeInfo);\n          locationHistory.add(routeInfo);\n        }\n      } else {\n        locationHistory.add(routeInfo);\n      }\n      /**\n       * If we recently reset the location history\n       * then we also need to update the initial\n       * history position.\n       */\n      if (locationHistory.size() === 1) {\n        initialHistoryPosition = routeInfo.position;\n      }\n      currentRouteInfo = routeInfo;\n    }\n    incomingRouteParams = undefined;\n    historyChangeListeners.forEach(cb => cb(currentRouteInfo));\n  };\n  const getCurrentRouteInfo = () => currentRouteInfo;\n  const canGoBack = (deep = 1) => locationHistory.canGoBack(deep, initialHistoryPosition, currentHistoryPosition);\n  const navigate = navigationOptions => {\n    const {\n      routerAnimation,\n      routerDirection,\n      routerLink\n    } = navigationOptions;\n    setIncomingRouteParams(\"push\", routerDirection, routerAnimation);\n    router.push(routerLink);\n  };\n  const resetTab = tab => {\n    /**\n     * Resetting the tab should go back\n     * to the initial view in the tab stack.\n     * It should not push a new instance of the\n     * root tab page onto the stack.\n     *\n     * To do this, we get the initial view in the\n     * tab stack and subtract the position of that\n     * entry from our current position. From there\n     * we call router.go() to move us back the\n     * appropriate number of positions.\n     */\n    const routeInfo = locationHistory.getFirstRouteInfoForTab(tab);\n    if (routeInfo) {\n      router.go(routeInfo.position - currentHistoryPosition);\n    }\n  };\n  const changeTab = (tab, path) => {\n    if (!path) return;\n    const routeInfo = locationHistory.getCurrentRouteInfoForTab(tab);\n    const [pathname] = path.split(\"?\");\n    if (routeInfo) {\n      incomingRouteParams = Object.assign(Object.assign({}, incomingRouteParams), {\n        routerAction: \"push\",\n        routerDirection: \"none\",\n        tab\n      });\n      /**\n       * When going back to a tab\n       * you just left, it's possible\n       * for the route info to be incorrect\n       * as the tab you want is not the\n       * tab you are on.\n       */\n      if (routeInfo.pathname === pathname) {\n        router.push({\n          path: routeInfo.pathname,\n          query: parseQuery(routeInfo.search)\n        });\n      } else {\n        router.push({\n          path: pathname,\n          query: parseQuery(routeInfo.search)\n        });\n      }\n    } else {\n      handleNavigate(pathname, \"push\", \"none\", undefined, tab);\n    }\n  };\n  /**\n   * This method is invoked by the IonTabs component\n   * during a history change callback. It is responsible\n   * for ensuring that tabbed routes have the correct\n   * \"tab\" field in its routeInfo object.\n   *\n   * IonTabs will determine if the current route\n   * is in tabs and assign it the correct tab.\n   * If the current route is not in tabs,\n   * then IonTabs will not invoke this.\n   */\n  const handleSetCurrentTab = tab => {\n    /**\n     * Note that the current page that we\n     * are on is not necessarily the last item\n     * in the locationHistory stack. As a result,\n     * we cannot use locationHistory.last() here.\n     */\n    const ri = Object.assign({}, locationHistory.current(initialHistoryPosition, currentHistoryPosition));\n    /**\n     * handleHistoryChange is tabs-agnostic by design.\n     * One side effect of this is that certain tabs\n     * routes have extraneous/incorrect information\n     * that we need to remove. To not tightly couple\n     * handleHistoryChange with tabs, we let the\n     * handleSetCurrentTab function. This function is\n     * only called by IonTabs.\n     */\n    if (ri.tab !== tab) {\n      ri.tab = tab;\n      locationHistory.update(ri);\n    }\n    /**\n     * lastPathname typically equals pushedByRoute\n     * when navigating in a linear manner. When switching between\n     * tabs, this is almost never the case.\n     *\n     * Example: /tabs/tabs1 --> /tabs/tab2 --> /tabs/tab1\n     * The latest Tab 1 route would have the following information\n     * lastPathname: '/tabs/tab2'\n     * pushedByRoute: '/tabs/tab2'\n     *\n     * A tab cannot push another tab, so we need to set\n     * pushedByRoute to `undefined`. Alternative way of thinking\n     * about this: You cannot swipe to go back from Tab 1 to Tab 2.\n     *\n     * However, there are some instances where we do want to keep\n     * the pushedByRoute. As a result, we need to ensure that\n     * we only wipe the pushedByRoute state when the both of the\n     * following conditions are met:\n     * 1. pushedByRoute is different from lastPathname\n     * 2. The tab for the pushedByRoute info is different\n     * from the current route tab.\n     *\n     * Example of when we would not want to clear pushedByRoute:\n     * /tabs/tab1 --> /tabs/tab1/child --> /tabs/tab2 --> /tabs/tab1/child\n     * The latest Tab 1 Child route would have the following information:\n     * lastPathname: '/tabs/tab2'\n     * pushedByRoute: '/tabs/tab1\n     *\n     * In this case, /tabs/tab1/child should be able to swipe to go back\n     * to /tabs/tab1 so we want to keep the pushedByRoute.\n     */\n    const pushedByRoute = locationHistory.findLastLocation(ri);\n    if (ri.pushedByRoute !== ri.lastPathname && (pushedByRoute === null || pushedByRoute === void 0 ? void 0 : pushedByRoute.tab) !== tab) {\n      ri.pushedByRoute = undefined;\n      locationHistory.update(ri);\n    }\n  };\n  const registerHistoryChangeListener = cb => {\n    historyChangeListeners.push(cb);\n  };\n  const setIncomingRouteParams = (routerAction = \"push\", routerDirection = \"forward\", routerAnimation, tab) => {\n    incomingRouteParams = {\n      routerAction,\n      routerDirection,\n      routerAnimation,\n      tab\n    };\n  };\n  const goBack = routerAnimation => {\n    setIncomingRouteParams(\"pop\", \"back\", routerAnimation);\n    router.back();\n  };\n  const goForward = routerAnimation => {\n    setIncomingRouteParams(\"push\", \"forward\", routerAnimation);\n    router.forward();\n  };\n  const getLeavingRouteInfo = () => {\n    return locationHistory.current(initialHistoryPosition, currentHistoryPosition);\n  };\n  return {\n    handleNavigate,\n    getLeavingRouteInfo,\n    handleNavigateBack,\n    handleSetCurrentTab,\n    getCurrentRouteInfo,\n    canGoBack,\n    navigate,\n    resetTab,\n    changeTab,\n    registerHistoryChangeListener,\n    goBack,\n    goForward\n  };\n};\nconst createViewStacks = router => {\n  const viewStacks = {};\n  /**\n   * Returns the number of active stacks.\n   * This is useful for determining if an app\n   * is using linear navigation only or non-linear\n   * navigation. Multiple stacks indiciate an app\n   * is using non-linear navigation.\n   */\n  const size = () => Object.keys(viewStacks).length;\n  const clear = outletId => {\n    delete viewStacks[outletId];\n  };\n  const getViewStack = outletId => {\n    return viewStacks[outletId];\n  };\n  const registerIonPage = (viewItem, ionPage) => {\n    viewItem.ionPageElement = ionPage;\n    viewItem.ionRoute = true;\n    /**\n     * This is needed otherwise Vue Router\n     * will not consider this component mounted\n     * and will not run route guards that\n     * are written in the component.\n     */\n    viewItem.matchedRoute.instances = {\n      default: viewItem.vueComponentRef.value\n    };\n  };\n  const findViewItemByRouteInfo = (routeInfo, outletId) => {\n    return findViewItemByPath(routeInfo.pathname, outletId, false);\n  };\n  const findLeavingViewItemByRouteInfo = (routeInfo, outletId, mustBeIonRoute = true) => {\n    return findViewItemByPath(routeInfo.lastPathname, outletId, mustBeIonRoute);\n  };\n  const findViewItemByPathname = (pathname, outletId) => {\n    return findViewItemByPath(pathname, outletId, false);\n  };\n  const findViewItemInStack = (path, stack) => {\n    return stack.find(viewItem => {\n      if (viewItem.pathname === path) {\n        return viewItem;\n      }\n      return undefined;\n    });\n  };\n  const findViewItemByPath = (path, outletId, mustBeIonRoute = false) => {\n    const matchView = viewItem => {\n      if (mustBeIonRoute && !viewItem.ionRoute || path === \"\") {\n        return false;\n      }\n      const resolvedPath = router.resolve(path);\n      const findMatchedRoute = resolvedPath.matched.find(matchedRoute => matchedRoute === viewItem.matchedRoute);\n      if (findMatchedRoute) {\n        /**\n         * /page/1 and /page/2 should not match\n         * to the same view item otherwise there will\n         * be not page transition and we will need to\n         * explicitly clear out parameters from page 1\n         * so the page 2 params are properly passed\n         * to the developer's app.\n         */\n        const hasParameter = findMatchedRoute.path.includes(\":\");\n        if (hasParameter && path !== viewItem.pathname) {\n          return false;\n        }\n        return viewItem;\n      }\n      return undefined;\n    };\n    if (outletId) {\n      const stack = viewStacks[outletId];\n      if (!stack) return undefined;\n      const match = router ? stack.find(matchView) : findViewItemInStack(path, stack);\n      if (match) return match;\n    } else {\n      for (const outletId in viewStacks) {\n        const stack = viewStacks[outletId];\n        const viewItem = findViewItemInStack(path, stack);\n        if (viewItem) {\n          return viewItem;\n        }\n      }\n    }\n    return undefined;\n  };\n  // TODO(FW-2969): type\n  const createViewItem = (outletId, vueComponent, matchedRoute, routeInfo, ionPage) => {\n    return {\n      id: generateId(\"viewItem\"),\n      pathname: routeInfo.pathname,\n      outletId,\n      matchedRoute,\n      ionPageElement: ionPage,\n      vueComponent,\n      vueComponentRef: shallowRef(),\n      ionRoute: false,\n      mount: false,\n      exact: routeInfo.pathname === matchedRoute.path,\n      params: routeInfo.params,\n      vueComponentData: {}\n    };\n  };\n  const add = viewItem => {\n    const {\n      outletId\n    } = viewItem;\n    if (!viewStacks[outletId]) {\n      viewStacks[outletId] = [viewItem];\n    } else {\n      viewStacks[outletId].push(viewItem);\n    }\n  };\n  const remove = (viewItem, outletId) => {\n    if (!outletId) {\n      throw Error(\"outletId required\");\n    }\n    const viewStack = viewStacks[outletId];\n    if (viewStack) {\n      viewStacks[outletId] = viewStack.filter(item => item.id !== viewItem.id);\n    }\n  };\n  const getChildrenToRender = outletId => {\n    const viewStack = viewStacks[outletId];\n    if (viewStack) {\n      const components = viewStacks[outletId].filter(v => v.mount);\n      return components;\n    }\n    return [];\n  };\n  /**\n   * When navigating backwards, we need to clean up and\n   * leaving pages so that they are re-created if\n   * we ever navigate back to them. This is especially\n   * important when using router.go and stepping back\n   * multiple pages at a time.\n   */\n  const unmountLeavingViews = (outletId, viewItem, delta = 1) => {\n    const viewStack = viewStacks[outletId];\n    if (!viewStack) return;\n    const startIndex = viewStack.findIndex(v => v === viewItem);\n    for (let i = startIndex + 1; i < startIndex - delta; i++) {\n      const viewItem = viewStack[i];\n      viewItem.mount = false;\n      viewItem.ionPageElement = undefined;\n      viewItem.ionRoute = false;\n      viewItem.matchedRoute.instances = {};\n    }\n  };\n  /**\n   * When navigating forward it is possible for\n   * developers to step forward over multiple views.\n   * The intermediary views need to be remounted so that\n   * swipe to go back works properly.\n   * We need to account for the delta value here too because\n   * we do not want to remount an unrelated view.\n   * Example:\n   * /home --> /page2 --> router.back() --> /page3\n   * Going to /page3 would remount /page2 since we do\n   * not prune /page2 from the stack. However, /page2\n   * needs to remain in the stack.\n   * Example:\n   * /home --> /page2 --> /page3 --> router.go(-2) --> router.go(2)\n   * We would end up on /page3, but users need to be able to swipe\n   * to go back to /page2 and /home, so we need both pages mounted\n   * in the DOM.\n   */\n  const mountIntermediaryViews = (outletId, viewItem, delta = 1) => {\n    const viewStack = viewStacks[outletId];\n    if (!viewStack) return;\n    const startIndex = viewStack.findIndex(v => v === viewItem);\n    for (let i = startIndex + 1; i < startIndex + delta; i++) {\n      viewStack[i].mount = true;\n    }\n  };\n  return {\n    unmountLeavingViews,\n    mountIntermediaryViews,\n    clear,\n    findViewItemByRouteInfo,\n    findLeavingViewItemByRouteInfo,\n    findViewItemByPathname,\n    createViewItem,\n    getChildrenToRender,\n    add,\n    remove,\n    registerIonPage,\n    getViewStack,\n    size\n  };\n};\nconst createRouter = opts => {\n  const routerOptions = Object.assign({}, opts);\n  delete routerOptions.tabsPrefix;\n  const router = createRouter$1(routerOptions);\n  const ionRouter = createIonRouter(opts, router);\n  const viewStacks = createViewStacks(router);\n  const oldInstall = router.install.bind(router);\n  router.install = app => {\n    app.provide(\"navManager\", ionRouter);\n    app.provide(\"viewStacks\", viewStacks);\n    oldInstall(app);\n  };\n  const oldIsReady = router.isReady.bind(router);\n  router.isReady = () => oldIsReady();\n  return router;\n};\nconst createWebHistory = base => createWebHistory$1(base);\nconst createWebHashHistory = base => createWebHashHistory$1(base);\nconst createMemoryHistory = base => createMemoryHistory$1(base);\nexport { createMemoryHistory, createRouter, createWebHashHistory, createWebHistory };","map":{"version":3,"names":["createLocationHistory","locationHistory","tabsHistory","add","routeInfo","routerAction","pop","addRoute","routerDirection","clearHistory","update","locationIndex","findIndex","x","id","splice","tabArray","tab","tabIndex","push","tabHistory","getTabsHistory","ri","length","position","existingRouteIndex","r","clearTabHistory","existingTabRouteIndex","history","size","current","initialHistory","currentHistory","index","last","canGoBack","deep","getFirstRouteInfoForTab","undefined","getCurrentRouteInfoForTab","findLastLocation","delta","routeInfos","i","pathname","pushedByRoute","ids","main","generateId","type","_a","toString","createIonRouter","opts","router","currentNavigationInfo","direction","action","afterEach","to","_","failure","currentHistoryPosition","state","replaceAction","replaced","handleHistoryChange","initialHistoryPosition","currentRouteInfo","incomingRouteParams","historyChangeListeners","document","addEventListener","ev","detail","register","processNextHandler","go","listen","_x","info","handleNavigateBack","defaultHref","routerAnimation","prevInfo","Object","assign","lastPathname","back","handleNavigate","path","setIncomingRouteParams","replace","location","leavingLocationInfo","search","leavingUrl","fullPath","prevRouteInfo","isPushed","split","params","prevRouteLastPathname","route","lastRoute","currentPushedBy","historySize","historyDiff","isReplacing","forEach","cb","getCurrentRouteInfo","navigate","navigationOptions","routerLink","resetTab","changeTab","query","parseQuery","handleSetCurrentTab","registerHistoryChangeListener","goBack","goForward","forward","getLeavingRouteInfo","createViewStacks","viewStacks","keys","clear","outletId","getViewStack","registerIonPage","viewItem","ionPage","ionPageElement","ionRoute","matchedRoute","instances","default","vueComponentRef","value","findViewItemByRouteInfo","findViewItemByPath","findLeavingViewItemByRouteInfo","mustBeIonRoute","findViewItemByPathname","findViewItemInStack","stack","find","matchView","resolvedPath","resolve","findMatchedRoute","matched","hasParameter","includes","match","createViewItem","vueComponent","shallowRef","mount","exact","vueComponentData","remove","Error","viewStack","filter","item","getChildrenToRender","components","v","unmountLeavingViews","startIndex","mountIntermediaryViews","createRouter","routerOptions","tabsPrefix","createRouter$1","ionRouter","oldInstall","install","bind","app","provide","oldIsReady","isReady","createWebHistory","base","createWebHistory$1","createWebHashHistory","createWebHashHistory$1","createMemoryHistory","createMemoryHistory$1"],"sources":["../src/locationHistory.ts","../src/utils.ts","../src/router.ts","../src/viewStacks.ts","../src/index.ts"],"sourcesContent":[null,null,null,null,null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}