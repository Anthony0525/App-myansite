{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { defineComponent, ref, onMounted, getCurrentInstance, inject, h, withDirectives, computed, provide, shallowRef, watch, onUnmounted, Fragment, isVNode, Teleport } from 'vue';\nimport { defineCustomElement } from '@ionic/core/components/ion-accordion.js';\nimport { defineCustomElement as defineCustomElement$1 } from '@ionic/core/components/ion-accordion-group.js';\nimport { defineCustomElement as defineCustomElement$2 } from '@ionic/core/components/ion-avatar.js';\nimport { defineCustomElement as defineCustomElement$3 } from '@ionic/core/components/ion-backdrop.js';\nimport { defineCustomElement as defineCustomElement$4 } from '@ionic/core/components/ion-badge.js';\nimport { defineCustomElement as defineCustomElement$5 } from '@ionic/core/components/ion-breadcrumb.js';\nimport { defineCustomElement as defineCustomElement$6 } from '@ionic/core/components/ion-breadcrumbs.js';\nimport { defineCustomElement as defineCustomElement$7 } from '@ionic/core/components/ion-button.js';\nimport { defineCustomElement as defineCustomElement$8 } from '@ionic/core/components/ion-buttons.js';\nimport { defineCustomElement as defineCustomElement$9 } from '@ionic/core/components/ion-card.js';\nimport { defineCustomElement as defineCustomElement$a } from '@ionic/core/components/ion-card-content.js';\nimport { defineCustomElement as defineCustomElement$b } from '@ionic/core/components/ion-card-header.js';\nimport { defineCustomElement as defineCustomElement$c } from '@ionic/core/components/ion-card-subtitle.js';\nimport { defineCustomElement as defineCustomElement$d } from '@ionic/core/components/ion-card-title.js';\nimport { defineCustomElement as defineCustomElement$e } from '@ionic/core/components/ion-checkbox.js';\nimport { defineCustomElement as defineCustomElement$f } from '@ionic/core/components/ion-chip.js';\nimport { defineCustomElement as defineCustomElement$g } from '@ionic/core/components/ion-col.js';\nimport { defineCustomElement as defineCustomElement$h } from '@ionic/core/components/ion-content.js';\nimport { defineCustomElement as defineCustomElement$i } from '@ionic/core/components/ion-datetime.js';\nimport { defineCustomElement as defineCustomElement$j } from '@ionic/core/components/ion-datetime-button.js';\nimport { defineCustomElement as defineCustomElement$k } from '@ionic/core/components/ion-fab.js';\nimport { defineCustomElement as defineCustomElement$l } from '@ionic/core/components/ion-fab-button.js';\nimport { defineCustomElement as defineCustomElement$m } from '@ionic/core/components/ion-fab-list.js';\nimport { defineCustomElement as defineCustomElement$n } from '@ionic/core/components/ion-footer.js';\nimport { defineCustomElement as defineCustomElement$o } from '@ionic/core/components/ion-grid.js';\nimport { defineCustomElement as defineCustomElement$p } from '@ionic/core/components/ion-header.js';\nimport { defineCustomElement as defineCustomElement$q } from '@ionic/core/components/ion-img.js';\nimport { defineCustomElement as defineCustomElement$r } from '@ionic/core/components/ion-infinite-scroll.js';\nimport { defineCustomElement as defineCustomElement$s } from '@ionic/core/components/ion-infinite-scroll-content.js';\nimport { defineCustomElement as defineCustomElement$t } from '@ionic/core/components/ion-input.js';\nimport { defineCustomElement as defineCustomElement$u } from '@ionic/core/components/ion-input-otp.js';\nimport { defineCustomElement as defineCustomElement$v } from '@ionic/core/components/ion-input-password-toggle.js';\nimport { defineCustomElement as defineCustomElement$w } from '@ionic/core/components/ion-item.js';\nimport { defineCustomElement as defineCustomElement$x } from '@ionic/core/components/ion-item-divider.js';\nimport { defineCustomElement as defineCustomElement$y } from '@ionic/core/components/ion-item-group.js';\nimport { defineCustomElement as defineCustomElement$z } from '@ionic/core/components/ion-item-option.js';\nimport { defineCustomElement as defineCustomElement$A } from '@ionic/core/components/ion-item-options.js';\nimport { defineCustomElement as defineCustomElement$B } from '@ionic/core/components/ion-item-sliding.js';\nimport { defineCustomElement as defineCustomElement$C } from '@ionic/core/components/ion-label.js';\nimport { defineCustomElement as defineCustomElement$D } from '@ionic/core/components/ion-list.js';\nimport { defineCustomElement as defineCustomElement$E } from '@ionic/core/components/ion-list-header.js';\nimport { defineCustomElement as defineCustomElement$F } from '@ionic/core/components/ion-menu.js';\nimport { defineCustomElement as defineCustomElement$G } from '@ionic/core/components/ion-menu-button.js';\nimport { defineCustomElement as defineCustomElement$H } from '@ionic/core/components/ion-menu-toggle.js';\nimport { defineCustomElement as defineCustomElement$1j } from '@ionic/core/components/ion-nav.js';\nimport { defineCustomElement as defineCustomElement$I } from '@ionic/core/components/ion-nav-link.js';\nimport { defineCustomElement as defineCustomElement$J } from '@ionic/core/components/ion-note.js';\nimport { defineCustomElement as defineCustomElement$K } from '@ionic/core/components/ion-picker.js';\nimport { defineCustomElement as defineCustomElement$L } from '@ionic/core/components/ion-picker-column.js';\nimport { defineCustomElement as defineCustomElement$M } from '@ionic/core/components/ion-picker-column-option.js';\nimport { defineCustomElement as defineCustomElement$N } from '@ionic/core/components/ion-progress-bar.js';\nimport { defineCustomElement as defineCustomElement$O } from '@ionic/core/components/ion-radio.js';\nimport { defineCustomElement as defineCustomElement$P } from '@ionic/core/components/ion-radio-group.js';\nimport { defineCustomElement as defineCustomElement$Q } from '@ionic/core/components/ion-range.js';\nimport { defineCustomElement as defineCustomElement$R } from '@ionic/core/components/ion-refresher.js';\nimport { defineCustomElement as defineCustomElement$S } from '@ionic/core/components/ion-refresher-content.js';\nimport { defineCustomElement as defineCustomElement$T } from '@ionic/core/components/ion-reorder.js';\nimport { defineCustomElement as defineCustomElement$U } from '@ionic/core/components/ion-reorder-group.js';\nimport { defineCustomElement as defineCustomElement$V } from '@ionic/core/components/ion-ripple-effect.js';\nimport { defineCustomElement as defineCustomElement$W } from '@ionic/core/components/ion-row.js';\nimport { defineCustomElement as defineCustomElement$X } from '@ionic/core/components/ion-searchbar.js';\nimport { defineCustomElement as defineCustomElement$Y } from '@ionic/core/components/ion-segment.js';\nimport { defineCustomElement as defineCustomElement$Z } from '@ionic/core/components/ion-segment-button.js';\nimport { defineCustomElement as defineCustomElement$_ } from '@ionic/core/components/ion-segment-content.js';\nimport { defineCustomElement as defineCustomElement$$ } from '@ionic/core/components/ion-segment-view.js';\nimport { defineCustomElement as defineCustomElement$10 } from '@ionic/core/components/ion-select.js';\nimport { defineCustomElement as defineCustomElement$11 } from '@ionic/core/components/ion-select-modal.js';\nimport { defineCustomElement as defineCustomElement$12 } from '@ionic/core/components/ion-select-option.js';\nimport { defineCustomElement as defineCustomElement$13 } from '@ionic/core/components/ion-skeleton-text.js';\nimport { defineCustomElement as defineCustomElement$14 } from '@ionic/core/components/ion-spinner.js';\nimport { defineCustomElement as defineCustomElement$15 } from '@ionic/core/components/ion-split-pane.js';\nimport { defineCustomElement as defineCustomElement$16 } from '@ionic/core/components/ion-tab.js';\nimport { defineCustomElement as defineCustomElement$17 } from '@ionic/core/components/ion-text.js';\nimport { defineCustomElement as defineCustomElement$18 } from '@ionic/core/components/ion-textarea.js';\nimport { defineCustomElement as defineCustomElement$19 } from '@ionic/core/components/ion-thumbnail.js';\nimport { defineCustomElement as defineCustomElement$1a } from '@ionic/core/components/ion-title.js';\nimport { defineCustomElement as defineCustomElement$1b } from '@ionic/core/components/ion-toggle.js';\nimport { defineCustomElement as defineCustomElement$1c } from '@ionic/core/components/ion-toolbar.js';\nimport { LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, initialize, modalController as modalController$1, popoverController as popoverController$1, alertController as alertController$1, actionSheetController as actionSheetController$1, loadingController as loadingController$1, pickerController as pickerController$1, toastController as toastController$1 } from '@ionic/core/components';\nexport { IonicSafeString, IonicSlides, createAnimation, createGesture, getIonPageElement, getPlatforms, getTimeGivenProgression, iosTransitionAnimation, isPlatform, mdTransitionAnimation, menuController, openURL } from '@ionic/core/components';\nimport { defineCustomElement as defineCustomElement$1d } from '@ionic/core/components/ion-back-button.js';\nimport { defineCustomElement as defineCustomElement$1e } from '@ionic/core/components/ion-router-outlet.js';\nimport { routeLocationKey, useRoute, matchedRouteKey } from 'vue-router';\nimport { defineCustomElement as defineCustomElement$1f } from '@ionic/core/components/ion-tab-button.js';\nimport { defineCustomElement as defineCustomElement$1g } from '@ionic/core/components/ion-tabs.js';\nimport { defineCustomElement as defineCustomElement$1h } from '@ionic/core/components/ion-tab-bar.js';\nimport { defineCustomElement as defineCustomElement$1i } from '@ionic/core/components/ion-app.js';\nimport { defineCustomElement as defineCustomElement$1k } from 'ionicons/components/ion-icon.js';\nimport { defineCustomElement as defineCustomElement$1l } from '@ionic/core/components/ion-action-sheet.js';\nimport { defineCustomElement as defineCustomElement$1m } from '@ionic/core/components/ion-alert.js';\nimport { defineCustomElement as defineCustomElement$1n } from '@ionic/core/components/ion-loading.js';\nimport { defineCustomElement as defineCustomElement$1o } from '@ionic/core/components/ion-modal.js';\nimport { defineCustomElement as defineCustomElement$1p } from '@ionic/core/components/ion-picker-legacy.js';\nimport { defineCustomElement as defineCustomElement$1q } from '@ionic/core/components/ion-popover.js';\nimport { defineCustomElement as defineCustomElement$1r } from '@ionic/core/components/ion-toast.js';\nconst UPDATE_VALUE_EVENT = 'update:modelValue';\nconst MODEL_VALUE = 'modelValue';\nconst ROUTER_LINK_VALUE = 'routerLink';\nconst NAV_MANAGER = 'navManager';\nconst ROUTER_PROP_PREFIX = 'router';\nconst ARIA_PROP_PREFIX = 'aria';\n/**\n * Starting in Vue 3.1.0, all properties are\n * added as keys to the props object, even if\n * they are not being used. In order to correctly\n * account for both value props and v-model props,\n * we need to check if the key exists for Vue <3.1.0\n * and then check if it is not undefined for Vue >= 3.1.0.\n * See https://github.com/vuejs/vue-next/issues/3889\n */\nconst EMPTY_PROP$1 = Symbol();\nconst DEFAULT_EMPTY_PROP$1 = {\n  default: EMPTY_PROP$1\n};\nconst getComponentClasses = classes => {\n  return classes?.split(' ') || [];\n};\nconst getElementClasses = (ref, componentClasses, defaultClasses = []) => {\n  return [...Array.from(ref.value?.classList || []), ...defaultClasses].filter((c, i, self) => !componentClasses.has(c) && self.indexOf(c) === i);\n};\n/**\n * Create a callback to define a Vue component wrapper around a Web Component.\n *\n * @prop name - The component tag name (i.e. `ion-button`)\n * @prop componentProps - An array of properties on the\n * component. These usually match up with the @Prop definitions\n * in each component's TSX file.\n * @prop emitProps - An array of for event listener on the Component.\n * these usually match up with the @Event definitions\n * in each compont's TSX file.\n * @prop customElement - An option custom element instance to pass\n * to customElements.define. Only set if `includeImportCustomElements: true` in your config.\n * @prop modelProp - The prop that v-model binds to (i.e. value)\n * @prop modelUpdateEvent - The event that is fired from your Web Component when the value changes (i.e. ionChange)\n */\nconst defineContainer = (name, defineCustomElement, componentProps = [], emitProps = [], modelProp, modelUpdateEvent) => {\n  /**\n   * Create a Vue component wrapper around a Web Component.\n   * Note: The `props` here are not all properties on a component.\n   * They refer to whatever properties are set on an instance of a component.\n   */\n  if (defineCustomElement !== undefined) {\n    defineCustomElement();\n  }\n  const emits = emitProps;\n  const props = [ROUTER_LINK_VALUE, ...componentProps].reduce((acc, prop) => {\n    acc[prop] = DEFAULT_EMPTY_PROP$1;\n    return acc;\n  }, {});\n  if (modelProp) {\n    emits.push(UPDATE_VALUE_EVENT);\n    props[MODEL_VALUE] = DEFAULT_EMPTY_PROP$1;\n  }\n  return defineComponent((props, {\n    attrs,\n    slots,\n    emit\n  }) => {\n    let modelPropValue = modelProp ? props[modelProp] : undefined;\n    const containerRef = ref();\n    const classes = new Set(getComponentClasses(attrs.class));\n    onMounted(() => {\n      /**\n       * we register the event emmiter for @Event definitions\n       * so we can use @event\n       */\n      emitProps.forEach(eventName => {\n        containerRef.value?.addEventListener(eventName, e => {\n          emit(eventName, e);\n        });\n      });\n    });\n    /**\n     * This directive is responsible for updating any reactive\n     * reference associated with v-model on the component.\n     * This code must be run inside of the \"created\" callback.\n     * Since the following listener callbacks as well as any potential\n     * event callback defined in the developer's app are set on\n     * the same element, we need to make sure the following callbacks\n     * are set first so they fire first. If the developer's callback fires first\n     * then the reactive reference will not have been updated yet.\n     */\n    const vModelDirective = {\n      created: el => {\n        const eventsNames = (Array.isArray(modelUpdateEvent) ? modelUpdateEvent : [modelUpdateEvent]).map(ev => ev.replace(/-([a-z])/g, g => g[1].toUpperCase()));\n        eventsNames.forEach(eventName => {\n          el.addEventListener(eventName, e => {\n            /**\n             * Only update the v-model binding if the event's target is the element we are\n             * listening on. For example, Component A could emit ionChange, but it could also\n             * have a descendant Component B that also emits ionChange. We only want to update\n             * the v-model for Component A when ionChange originates from that element and not\n             * when ionChange bubbles up from Component B.\n             */\n            if (e.target.tagName === el.tagName && modelProp) {\n              modelPropValue = (e?.target)[modelProp];\n              emit(UPDATE_VALUE_EVENT, modelPropValue);\n            }\n          });\n        });\n      }\n    };\n    const currentInstance = getCurrentInstance();\n    const hasRouter = currentInstance?.appContext?.provides[NAV_MANAGER];\n    const navManager = hasRouter ? inject(NAV_MANAGER) : undefined;\n    const handleRouterLink = ev => {\n      const {\n        routerLink\n      } = props;\n      if (routerLink === EMPTY_PROP$1) return;\n      if (navManager !== undefined) {\n        /**\n         * This prevents the browser from\n         * performing a page reload when pressing\n         * an Ionic component with routerLink.\n         * The page reload interferes with routing\n         * and causes ion-back-button to disappear\n         * since the local history is wiped on reload.\n         */\n        ev.preventDefault();\n        let navigationPayload = {\n          event: ev\n        };\n        for (const key in props) {\n          const value = props[key];\n          if (props.hasOwnProperty(key) && key.startsWith(ROUTER_PROP_PREFIX) && value !== EMPTY_PROP$1) {\n            navigationPayload[key] = value;\n          }\n        }\n        navManager.navigate(navigationPayload);\n      } else {\n        console.warn('Tried to navigate, but no router was found. Make sure you have mounted Vue Router.');\n      }\n    };\n    return () => {\n      modelPropValue = props[modelProp];\n      getComponentClasses(attrs.class).forEach(value => {\n        classes.add(value);\n      });\n      // @ts-expect-error\n      const oldClick = props.onClick;\n      const handleClick = ev => {\n        if (oldClick !== undefined) {\n          oldClick(ev);\n        }\n        if (!ev.defaultPrevented) {\n          handleRouterLink(ev);\n        }\n      };\n      const propsToAdd = {\n        ref: containerRef,\n        class: getElementClasses(containerRef, classes),\n        onClick: handleClick\n      };\n      /**\n       * We can use Object.entries here\n       * to avoid the hasOwnProperty check,\n       * but that would require 2 iterations\n       * where as this only requires 1.\n       */\n      for (const key in props) {\n        const value = props[key];\n        if (props.hasOwnProperty(key) && value !== EMPTY_PROP$1 || key.startsWith(ARIA_PROP_PREFIX)) {\n          propsToAdd[key] = value;\n        }\n        /**\n         * register event handlers on the component\n         */\n        const eventHandlerKey = 'on' + key.slice(0, 1).toUpperCase() + key.slice(1);\n        const eventHandler = attrs[eventHandlerKey];\n        if (containerRef.value && attrs.hasOwnProperty(eventHandlerKey) && 'addEventListener' in containerRef.value) {\n          containerRef.value.addEventListener(key, eventHandler);\n        }\n      }\n      if (modelProp) {\n        /**\n         * If form value property was set using v-model\n         * then we should use that value.\n         * Otherwise, check to see if form value property\n         * was set as a static value (i.e. no v-model).\n         */\n        if (props[MODEL_VALUE] !== EMPTY_PROP$1) {\n          propsToAdd[modelProp] = props[MODEL_VALUE];\n        } else if (modelPropValue !== EMPTY_PROP$1) {\n          propsToAdd[modelProp] = modelPropValue;\n        }\n      }\n      // If router link is defined, add href to props\n      // in order to properly render an anchor tag inside\n      // of components that should become activatable and\n      // focusable with router link.\n      if (ROUTER_LINK_VALUE in props && props[ROUTER_LINK_VALUE] !== EMPTY_PROP$1) {\n        propsToAdd.href = props[ROUTER_LINK_VALUE];\n      }\n      /**\n       * vModelDirective is only needed on components that support v-model.\n       * As a result, we conditionally call withDirectives with v-model components.\n       */\n      const node = h(name, propsToAdd, slots.default && slots.default());\n      return modelProp === undefined ? node : withDirectives(node, [[vModelDirective]]);\n    };\n  }, {\n    name,\n    props,\n    emits\n  });\n};\n\n/* eslint-disable */\n/* tslint:disable */\n/* auto-generated vue proxies */\nconst IonAccordion = /*@__PURE__*/defineContainer('ion-accordion', defineCustomElement, ['value', 'disabled', 'readonly', 'toggleIcon', 'toggleIconSlot']);\nconst IonAccordionGroup = /*@__PURE__*/defineContainer('ion-accordion-group', defineCustomElement$1, ['animated', 'multiple', 'value', 'disabled', 'readonly', 'expand', 'ionChange', 'ionValueChange'], ['ionChange', 'ionValueChange'], 'value', 'ion-change');\nconst IonAvatar = /*@__PURE__*/defineContainer('ion-avatar', defineCustomElement$2);\nconst IonBackdrop = /*@__PURE__*/defineContainer('ion-backdrop', defineCustomElement$3, ['visible', 'tappable', 'stopPropagation', 'ionBackdropTap'], ['ionBackdropTap']);\nconst IonBadge = /*@__PURE__*/defineContainer('ion-badge', defineCustomElement$4, ['color']);\nconst IonBreadcrumb = /*@__PURE__*/defineContainer('ion-breadcrumb', defineCustomElement$5, ['collapsed', 'last', 'showCollapsedIndicator', 'color', 'active', 'disabled', 'download', 'href', 'rel', 'separator', 'target', 'routerDirection', 'routerAnimation', 'ionFocus', 'ionBlur', 'collapsedClick'], ['ionFocus', 'ionBlur', 'collapsedClick']);\nconst IonBreadcrumbs = /*@__PURE__*/defineContainer('ion-breadcrumbs', defineCustomElement$6, ['color', 'maxItems', 'itemsBeforeCollapse', 'itemsAfterCollapse', 'ionCollapsedClick'], ['ionCollapsedClick']);\nconst IonButton = /*@__PURE__*/defineContainer('ion-button', defineCustomElement$7, ['color', 'buttonType', 'disabled', 'expand', 'fill', 'routerDirection', 'routerAnimation', 'download', 'href', 'rel', 'shape', 'size', 'strong', 'target', 'type', 'form', 'ionFocus', 'ionBlur'], ['ionFocus', 'ionBlur']);\nconst IonButtons = /*@__PURE__*/defineContainer('ion-buttons', defineCustomElement$8, ['collapse']);\nconst IonCard = /*@__PURE__*/defineContainer('ion-card', defineCustomElement$9, ['color', 'button', 'type', 'disabled', 'download', 'href', 'rel', 'routerDirection', 'routerAnimation', 'target']);\nconst IonCardContent = /*@__PURE__*/defineContainer('ion-card-content', defineCustomElement$a);\nconst IonCardHeader = /*@__PURE__*/defineContainer('ion-card-header', defineCustomElement$b, ['color', 'translucent']);\nconst IonCardSubtitle = /*@__PURE__*/defineContainer('ion-card-subtitle', defineCustomElement$c, ['color']);\nconst IonCardTitle = /*@__PURE__*/defineContainer('ion-card-title', defineCustomElement$d, ['color']);\nconst IonCheckbox = /*@__PURE__*/defineContainer('ion-checkbox', defineCustomElement$e, ['color', 'name', 'checked', 'indeterminate', 'disabled', 'errorText', 'helperText', 'value', 'labelPlacement', 'justify', 'alignment', 'required', 'ionChange', 'ionFocus', 'ionBlur'], ['ionChange', 'ionFocus', 'ionBlur'], 'checked', 'ion-change');\nconst IonChip = /*@__PURE__*/defineContainer('ion-chip', defineCustomElement$f, ['color', 'outline', 'disabled']);\nconst IonCol = /*@__PURE__*/defineContainer('ion-col', defineCustomElement$g, ['offset', 'offsetXs', 'offsetSm', 'offsetMd', 'offsetLg', 'offsetXl', 'pull', 'pullXs', 'pullSm', 'pullMd', 'pullLg', 'pullXl', 'push', 'pushXs', 'pushSm', 'pushMd', 'pushLg', 'pushXl', 'size', 'sizeXs', 'sizeSm', 'sizeMd', 'sizeLg', 'sizeXl']);\nconst IonContent = /*@__PURE__*/defineContainer('ion-content', defineCustomElement$h, ['color', 'fullscreen', 'fixedSlotPlacement', 'forceOverscroll', 'scrollX', 'scrollY', 'scrollEvents', 'ionScrollStart', 'ionScroll', 'ionScrollEnd'], ['ionScrollStart', 'ionScroll', 'ionScrollEnd']);\nconst IonDatetime = /*@__PURE__*/defineContainer('ion-datetime', defineCustomElement$i, ['color', 'name', 'disabled', 'formatOptions', 'readonly', 'isDateEnabled', 'showAdjacentDays', 'min', 'max', 'presentation', 'cancelText', 'doneText', 'clearText', 'yearValues', 'monthValues', 'dayValues', 'hourValues', 'minuteValues', 'locale', 'firstDayOfWeek', 'titleSelectedDatesFormatter', 'multiple', 'highlightedDates', 'value', 'showDefaultTitle', 'showDefaultButtons', 'showClearButton', 'showDefaultTimeLabel', 'hourCycle', 'size', 'preferWheel', 'ionCancel', 'ionChange', 'ionValueChange', 'ionFocus', 'ionBlur', 'ionStyle', 'ionRender'], ['ionCancel', 'ionChange', 'ionValueChange', 'ionFocus', 'ionBlur', 'ionStyle', 'ionRender'], 'value', 'ion-change');\nconst IonDatetimeButton = /*@__PURE__*/defineContainer('ion-datetime-button', defineCustomElement$j, ['color', 'disabled', 'datetime']);\nconst IonFab = /*@__PURE__*/defineContainer('ion-fab', defineCustomElement$k, ['horizontal', 'vertical', 'edge', 'activated']);\nconst IonFabButton = /*@__PURE__*/defineContainer('ion-fab-button', defineCustomElement$l, ['color', 'activated', 'disabled', 'download', 'href', 'rel', 'routerDirection', 'routerAnimation', 'target', 'show', 'translucent', 'type', 'size', 'closeIcon', 'ionFocus', 'ionBlur'], ['ionFocus', 'ionBlur']);\nconst IonFabList = /*@__PURE__*/defineContainer('ion-fab-list', defineCustomElement$m, ['activated', 'side']);\nconst IonFooter = /*@__PURE__*/defineContainer('ion-footer', defineCustomElement$n, ['collapse', 'translucent']);\nconst IonGrid = /*@__PURE__*/defineContainer('ion-grid', defineCustomElement$o, ['fixed']);\nconst IonHeader = /*@__PURE__*/defineContainer('ion-header', defineCustomElement$p, ['collapse', 'translucent']);\nconst IonImg = /*@__PURE__*/defineContainer('ion-img', defineCustomElement$q, ['alt', 'src', 'ionImgWillLoad', 'ionImgDidLoad', 'ionError'], ['ionImgWillLoad', 'ionImgDidLoad', 'ionError']);\nconst IonInfiniteScroll = /*@__PURE__*/defineContainer('ion-infinite-scroll', defineCustomElement$r, ['threshold', 'disabled', 'position', 'ionInfinite'], ['ionInfinite']);\nconst IonInfiniteScrollContent = /*@__PURE__*/defineContainer('ion-infinite-scroll-content', defineCustomElement$s, ['loadingSpinner', 'loadingText']);\nconst IonInput = /*@__PURE__*/defineContainer('ion-input', defineCustomElement$t, ['color', 'autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'clearInput', 'clearInputIcon', 'clearOnEdit', 'counter', 'counterFormatter', 'debounce', 'disabled', 'enterkeyhint', 'errorText', 'fill', 'inputmode', 'helperText', 'label', 'labelPlacement', 'max', 'maxlength', 'min', 'minlength', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'shape', 'spellcheck', 'step', 'type', 'value', 'ionInput', 'ionChange', 'ionBlur', 'ionFocus'], ['ionInput', 'ionChange', 'ionBlur', 'ionFocus'], 'value', 'ion-input');\nconst IonInputOtp = /*@__PURE__*/defineContainer('ion-input-otp', defineCustomElement$u, ['autocapitalize', 'color', 'disabled', 'fill', 'inputmode', 'length', 'pattern', 'readonly', 'separators', 'shape', 'size', 'type', 'value', 'ionInput', 'ionChange', 'ionComplete', 'ionBlur', 'ionFocus'], ['ionInput', 'ionChange', 'ionComplete', 'ionBlur', 'ionFocus'], 'value', 'ion-input');\nconst IonInputPasswordToggle = /*@__PURE__*/defineContainer('ion-input-password-toggle', defineCustomElement$v, ['color', 'showIcon', 'hideIcon', 'type']);\nconst IonItem = /*@__PURE__*/defineContainer('ion-item', defineCustomElement$w, ['color', 'button', 'detail', 'detailIcon', 'disabled', 'download', 'href', 'rel', 'lines', 'routerAnimation', 'routerDirection', 'target', 'type']);\nconst IonItemDivider = /*@__PURE__*/defineContainer('ion-item-divider', defineCustomElement$x, ['color', 'sticky']);\nconst IonItemGroup = /*@__PURE__*/defineContainer('ion-item-group', defineCustomElement$y);\nconst IonItemOption = /*@__PURE__*/defineContainer('ion-item-option', defineCustomElement$z, ['color', 'disabled', 'download', 'expandable', 'href', 'rel', 'target', 'type']);\nconst IonItemOptions = /*@__PURE__*/defineContainer('ion-item-options', defineCustomElement$A, ['side', 'ionSwipe'], ['ionSwipe']);\nconst IonItemSliding = /*@__PURE__*/defineContainer('ion-item-sliding', defineCustomElement$B, ['disabled', 'ionDrag'], ['ionDrag']);\nconst IonLabel = /*@__PURE__*/defineContainer('ion-label', defineCustomElement$C, ['color', 'position', 'ionColor', 'ionStyle'], ['ionColor', 'ionStyle']);\nconst IonList = /*@__PURE__*/defineContainer('ion-list', defineCustomElement$D, ['lines', 'inset']);\nconst IonListHeader = /*@__PURE__*/defineContainer('ion-list-header', defineCustomElement$E, ['color', 'lines']);\nconst IonMenu = /*@__PURE__*/defineContainer('ion-menu', defineCustomElement$F, ['contentId', 'menuId', 'type', 'disabled', 'side', 'swipeGesture', 'maxEdgeStart', 'ionWillOpen', 'ionWillClose', 'ionDidOpen', 'ionDidClose', 'ionMenuChange'], ['ionWillOpen', 'ionWillClose', 'ionDidOpen', 'ionDidClose', 'ionMenuChange']);\nconst IonMenuButton = /*@__PURE__*/defineContainer('ion-menu-button', defineCustomElement$G, ['color', 'disabled', 'menu', 'autoHide', 'type']);\nconst IonMenuToggle = /*@__PURE__*/defineContainer('ion-menu-toggle', defineCustomElement$H, ['menu', 'autoHide']);\nconst IonNavLink = /*@__PURE__*/defineContainer('ion-nav-link', defineCustomElement$I, ['component', 'componentProps', 'routerDirection', 'routerAnimation']);\nconst IonNote = /*@__PURE__*/defineContainer('ion-note', defineCustomElement$J, ['color']);\nconst IonPicker = /*@__PURE__*/defineContainer('ion-picker', defineCustomElement$K, ['ionInputModeChange'], ['ionInputModeChange']);\nconst IonPickerColumn = /*@__PURE__*/defineContainer('ion-picker-column', defineCustomElement$L, ['disabled', 'value', 'color', 'numericInput', 'ionChange'], ['ionChange']);\nconst IonPickerColumnOption = /*@__PURE__*/defineContainer('ion-picker-column-option', defineCustomElement$M, ['disabled', 'value', 'color']);\nconst IonProgressBar = /*@__PURE__*/defineContainer('ion-progress-bar', defineCustomElement$N, ['type', 'reversed', 'value', 'buffer', 'color']);\nconst IonRadio = /*@__PURE__*/defineContainer('ion-radio', defineCustomElement$O, ['color', 'name', 'disabled', 'value', 'labelPlacement', 'justify', 'alignment', 'ionFocus', 'ionBlur'], ['ionFocus', 'ionBlur'], 'value', 'ion-change');\nconst IonRadioGroup = /*@__PURE__*/defineContainer('ion-radio-group', defineCustomElement$P, ['allowEmptySelection', 'compareWith', 'name', 'value', 'helperText', 'errorText', 'ionChange', 'ionValueChange'], ['ionChange', 'ionValueChange'], 'value', 'ion-change');\nconst IonRange = /*@__PURE__*/defineContainer('ion-range', defineCustomElement$Q, ['color', 'debounce', 'name', 'label', 'dualKnobs', 'min', 'max', 'pin', 'pinFormatter', 'snaps', 'step', 'ticks', 'activeBarStart', 'disabled', 'value', 'labelPlacement', 'ionChange', 'ionInput', 'ionFocus', 'ionBlur', 'ionKnobMoveStart', 'ionKnobMoveEnd'], ['ionChange', 'ionInput', 'ionFocus', 'ionBlur', 'ionKnobMoveStart', 'ionKnobMoveEnd'], 'value', 'ion-input');\nconst IonRefresher = /*@__PURE__*/defineContainer('ion-refresher', defineCustomElement$R, ['pullMin', 'pullMax', 'closeDuration', 'snapbackDuration', 'pullFactor', 'disabled', 'ionRefresh', 'ionPull', 'ionStart'], ['ionRefresh', 'ionPull', 'ionStart']);\nconst IonRefresherContent = /*@__PURE__*/defineContainer('ion-refresher-content', defineCustomElement$S, ['pullingIcon', 'pullingText', 'refreshingSpinner', 'refreshingText']);\nconst IonReorder = /*@__PURE__*/defineContainer('ion-reorder', defineCustomElement$T);\nconst IonReorderGroup = /*@__PURE__*/defineContainer('ion-reorder-group', defineCustomElement$U, ['disabled', 'ionItemReorder', 'ionReorderStart', 'ionReorderMove', 'ionReorderEnd'], ['ionItemReorder', 'ionReorderStart', 'ionReorderMove', 'ionReorderEnd']);\nconst IonRippleEffect = /*@__PURE__*/defineContainer('ion-ripple-effect', defineCustomElement$V, ['type']);\nconst IonRow = /*@__PURE__*/defineContainer('ion-row', defineCustomElement$W);\nconst IonSearchbar = /*@__PURE__*/defineContainer('ion-searchbar', defineCustomElement$X, ['color', 'animated', 'autocapitalize', 'autocomplete', 'autocorrect', 'cancelButtonIcon', 'cancelButtonText', 'clearIcon', 'debounce', 'disabled', 'inputmode', 'enterkeyhint', 'maxlength', 'minlength', 'name', 'placeholder', 'searchIcon', 'showCancelButton', 'showClearButton', 'spellcheck', 'type', 'value', 'ionInput', 'ionChange', 'ionCancel', 'ionClear', 'ionBlur', 'ionFocus', 'ionStyle'], ['ionInput', 'ionChange', 'ionCancel', 'ionClear', 'ionBlur', 'ionFocus', 'ionStyle'], 'value', 'ion-input');\nconst IonSegment = /*@__PURE__*/defineContainer('ion-segment', defineCustomElement$Y, ['color', 'disabled', 'scrollable', 'swipeGesture', 'value', 'selectOnFocus', 'ionChange', 'ionSelect', 'ionStyle'], ['ionChange', 'ionSelect', 'ionStyle'], 'value', 'ion-change');\nconst IonSegmentButton = /*@__PURE__*/defineContainer('ion-segment-button', defineCustomElement$Z, ['contentId', 'disabled', 'layout', 'type', 'value'], [], 'value', 'ion-change');\nconst IonSegmentContent = /*@__PURE__*/defineContainer('ion-segment-content', defineCustomElement$_);\nconst IonSegmentView = /*@__PURE__*/defineContainer('ion-segment-view', defineCustomElement$$, ['disabled', 'ionSegmentViewScroll'], ['ionSegmentViewScroll']);\nconst IonSelect = /*@__PURE__*/defineContainer('ion-select', defineCustomElement$10, ['cancelText', 'color', 'compareWith', 'disabled', 'fill', 'errorText', 'helperText', 'interface', 'interfaceOptions', 'justify', 'label', 'labelPlacement', 'multiple', 'name', 'okText', 'placeholder', 'selectedText', 'toggleIcon', 'expandedIcon', 'shape', 'value', 'required', 'ionChange', 'ionCancel', 'ionDismiss', 'ionFocus', 'ionBlur', 'ionStyle'], ['ionChange', 'ionCancel', 'ionDismiss', 'ionFocus', 'ionBlur', 'ionStyle'], 'value', 'ion-change');\nconst IonSelectModal = /*@__PURE__*/defineContainer('ion-select-modal', defineCustomElement$11, ['header', 'multiple', 'options']);\nconst IonSelectOption = /*@__PURE__*/defineContainer('ion-select-option', defineCustomElement$12, ['disabled', 'value']);\nconst IonSkeletonText = /*@__PURE__*/defineContainer('ion-skeleton-text', defineCustomElement$13, ['animated', 'ionStyle'], ['ionStyle']);\nconst IonSpinner = /*@__PURE__*/defineContainer('ion-spinner', defineCustomElement$14, ['color', 'duration', 'name', 'paused']);\nconst IonSplitPane = /*@__PURE__*/defineContainer('ion-split-pane', defineCustomElement$15, ['contentId', 'disabled', 'when', 'ionSplitPaneVisible'], ['ionSplitPaneVisible']);\nconst IonTab = /*@__PURE__*/defineContainer('ion-tab', defineCustomElement$16, ['active', 'delegate', 'tab', 'component']);\nconst IonText = /*@__PURE__*/defineContainer('ion-text', defineCustomElement$17, ['color']);\nconst IonTextarea = /*@__PURE__*/defineContainer('ion-textarea', defineCustomElement$18, ['color', 'autocapitalize', 'autofocus', 'clearOnEdit', 'debounce', 'disabled', 'fill', 'inputmode', 'enterkeyhint', 'maxlength', 'minlength', 'name', 'placeholder', 'readonly', 'required', 'spellcheck', 'cols', 'rows', 'wrap', 'autoGrow', 'value', 'counter', 'counterFormatter', 'errorText', 'helperText', 'label', 'labelPlacement', 'shape', 'ionChange', 'ionInput', 'ionBlur', 'ionFocus'], ['ionChange', 'ionInput', 'ionBlur', 'ionFocus'], 'value', 'ion-input');\nconst IonThumbnail = /*@__PURE__*/defineContainer('ion-thumbnail', defineCustomElement$19);\nconst IonTitle = /*@__PURE__*/defineContainer('ion-title', defineCustomElement$1a, ['color', 'size', 'ionStyle'], ['ionStyle']);\nconst IonToggle = /*@__PURE__*/defineContainer('ion-toggle', defineCustomElement$1b, ['color', 'name', 'checked', 'disabled', 'errorText', 'helperText', 'value', 'enableOnOffLabels', 'labelPlacement', 'justify', 'alignment', 'required', 'ionChange', 'ionFocus', 'ionBlur'], ['ionChange', 'ionFocus', 'ionBlur'], 'checked', 'ion-change');\nconst IonToolbar = /*@__PURE__*/defineContainer('ion-toolbar', defineCustomElement$1c, ['color']);\nconst useBackButton = (priority, handler) => {\n  const callback = ev => ev.detail.register(priority, handler);\n  const unregister = () => document.removeEventListener(\"ionBackButton\", callback);\n  document.addEventListener(\"ionBackButton\", callback);\n  return {\n    unregister\n  };\n};\nconst useKeyboard = () => {\n  const isOpen = ref(false);\n  const keyboardHeight = ref(0);\n  const showCallback = ev => {\n    isOpen.value = true;\n    keyboardHeight.value = ev.detail.keyboardHeight;\n  };\n  const hideCallback = () => {\n    isOpen.value = false;\n    keyboardHeight.value = 0;\n  };\n  const unregister = () => {\n    if (typeof window !== \"undefined\") {\n      window.removeEventListener(\"ionKeyboardDidShow\", showCallback);\n      window.removeEventListener(\"ionKeyboardDidHide\", hideCallback);\n    }\n  };\n  if (typeof window !== \"undefined\") {\n    window.addEventListener(\"ionKeyboardDidShow\", showCallback);\n    window.addEventListener(\"ionKeyboardDidHide\", hideCallback);\n  }\n  return {\n    isOpen,\n    keyboardHeight,\n    unregister\n  };\n};\n\n// TODO(FW-2969): types\nvar LifecycleHooks;\n(function (LifecycleHooks) {\n  LifecycleHooks[\"WillEnter\"] = \"onIonViewWillEnter\";\n  LifecycleHooks[\"DidEnter\"] = \"onIonViewDidEnter\";\n  LifecycleHooks[\"WillLeave\"] = \"onIonViewWillLeave\";\n  LifecycleHooks[\"DidLeave\"] = \"onIonViewDidLeave\";\n})(LifecycleHooks || (LifecycleHooks = {}));\nconst hookNames = {\n  [LIFECYCLE_WILL_ENTER]: LifecycleHooks.WillEnter,\n  [LIFECYCLE_DID_ENTER]: LifecycleHooks.DidEnter,\n  [LIFECYCLE_WILL_LEAVE]: LifecycleHooks.WillLeave,\n  [LIFECYCLE_DID_LEAVE]: LifecycleHooks.DidLeave\n};\nconst ids = {\n  main: 0\n};\nconst generateId = (type = \"main\") => {\n  var _a;\n  const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;\n  ids[type] = id;\n  return id.toString();\n};\nconst fireLifecycle = (vueComponent, vueInstance, lifecycle) => {\n  if (vueComponent === null || vueComponent === void 0 ? void 0 : vueComponent[lifecycle]) {\n    vueComponent[lifecycle].bind(vueInstance === null || vueInstance === void 0 ? void 0 : vueInstance.value)();\n  }\n  const instance = vueInstance === null || vueInstance === void 0 ? void 0 : vueInstance.value;\n  if (instance === null || instance === void 0 ? void 0 : instance[lifecycle]) {\n    instance[lifecycle]();\n  }\n  /**\n   * Fire any Composition API\n   * Ionic Lifecycle hooks\n   */\n  if (instance) {\n    const hook = hookNames[lifecycle];\n    const hooks = instance[hook];\n    if (hooks) {\n      hooks.forEach(hook => hook());\n    }\n  }\n};\nconst getConfig = () => {\n  if (typeof window !== \"undefined\") {\n    const Ionic = window.Ionic;\n    if (Ionic && Ionic.config) {\n      return Ionic.config;\n    }\n  }\n  return null;\n};\n\n/**\n * Creates an returns a function that\n * can be used to provide a lifecycle hook.\n */\nconst injectHook = (lifecycleType, hook, component) => {\n  if (component) {\n    // Add to public instance so it is accessible to IonRouterOutlet\n    const target = component;\n    const hooks = target.proxy[lifecycleType] || (target.proxy[lifecycleType] = []);\n    /**\n     * Define property on public instances using `setup` syntax in Vue 3.x\n     */\n    if (target.exposed) {\n      target.exposed[lifecycleType] = hooks;\n    }\n    const wrappedHook = (...args) => {\n      if (target.isUnmounted) {\n        return;\n      }\n      return args ? hook(...args) : hook();\n    };\n    hooks.push(wrappedHook);\n    return wrappedHook;\n  } else {\n    console.warn(\"[@ionic/vue]: Ionic Lifecycle Hooks can only be used during execution of setup().\");\n  }\n};\nconst createHook = lifecycle => {\n  return (hook, target = getCurrentInstance()) => injectHook(lifecycle, hook, target);\n};\nconst onIonViewWillEnter = createHook(LifecycleHooks.WillEnter);\nconst onIonViewDidEnter = createHook(LifecycleHooks.DidEnter);\nconst onIonViewWillLeave = createHook(LifecycleHooks.WillLeave);\nconst onIonViewDidLeave = createHook(LifecycleHooks.DidLeave);\n\n/**\n * Used to navigate within Vue Router\n * while controlling the animation.\n */\nconst useIonRouter = () => {\n  const {\n    canGoBack,\n    goBack,\n    goForward,\n    handleNavigate\n  } = inject(\"navManager\");\n  const navigate = (location, routerDirection, routerAction, routerAnimation) => handleNavigate(location, routerAction, routerDirection, routerAnimation);\n  const push = (location, routerAnimation) => navigate(location, \"forward\", \"push\", routerAnimation);\n  const replace = (location, routerAnimation) => navigate(location, \"root\", \"replace\", routerAnimation);\n  const back = routerAnimation => goBack(routerAnimation);\n  const forward = routerAnimation => goForward(routerAnimation);\n  return {\n    canGoBack,\n    push,\n    replace,\n    back,\n    forward,\n    navigate\n  };\n};\nconst IonicVue = {\n  async install(_, config = {}) {\n    /**\n     * By default Ionic Framework hides elements that\n     * are not hydrated, but in the CE build there is no\n     * hydration.\n     * TODO FW-2797: Remove when all integrations have been\n     * migrated to CE build.\n     */\n    if (typeof document !== \"undefined\") {\n      document.documentElement.classList.add(\"ion-ce\");\n    }\n    initialize(config);\n  }\n};\nconst IonBackButton = /*@__PURE__*/defineComponent((_, {\n  attrs,\n  slots\n}) => {\n  defineCustomElement$1d();\n  // TODO(FW-2969): type\n  const ionRouter = inject(\"navManager\");\n  const onClick = () => {\n    /**\n     * When using ion-back-button outside of\n     * a routing context, ionRouter is undefined.\n     */\n    if (ionRouter === undefined) {\n      return;\n    }\n    const defaultHref = attrs[\"default-href\"] || attrs[\"defaultHref\"];\n    const routerAnimation = attrs[\"router-animation\"] || attrs[\"routerAnimation\"];\n    ionRouter.handleNavigateBack(defaultHref, routerAnimation);\n  };\n  return () => {\n    return h(\"ion-back-button\", Object.assign({\n      onClick\n    }, attrs), slots.default && slots.default());\n  };\n}, {\n  name: \"IonBackButton\"\n});\nconst IonPage = /*@__PURE__*/defineComponent({\n  name: \"IonPage\",\n  props: {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    registerIonPage: {\n      type: Function,\n      default: () => {}\n    }\n  },\n  mounted() {\n    this.$props.registerIonPage(this.$refs.ionPage);\n  },\n  setup(_, {\n    attrs,\n    slots\n  }) {\n    return () => {\n      return h(\"div\", Object.assign(Object.assign({}, attrs), {\n        [\"class\"]: \"ion-page\",\n        ref: \"ionPage\"\n      }), slots.default && slots.default());\n    };\n  }\n});\n\n// TODO(FW-2969): types\nconst isViewVisible = enteringEl => {\n  return !enteringEl.classList.contains(\"ion-page-hidden\") && !enteringEl.classList.contains(\"ion-page-invisible\");\n};\nconst viewDepthKey = Symbol(0);\nconst IonRouterOutlet = /*@__PURE__*/defineComponent({\n  name: \"IonRouterOutlet\",\n  setup() {\n    defineCustomElement$1e();\n    const injectedRoute = inject(routeLocationKey);\n    const route = useRoute();\n    const depth = inject(viewDepthKey, 0);\n    const matchedRouteRef = computed(() => route.matched[depth]);\n    let previousMatchedRouteRef;\n    let previousMatchedPath;\n    provide(viewDepthKey, depth + 1);\n    provide(matchedRouteKey, matchedRouteRef);\n    const ionRouterOutlet = ref();\n    const id = generateId(\"ion-router-outlet\");\n    const ionRouter = inject(\"navManager\");\n    const viewStacks = inject(\"viewStacks\");\n    const components = shallowRef([]);\n    let skipTransition = false;\n    // The base url for this router outlet\n    let parentOutletPath;\n    /**\n     * Note: Do not listen for matchedRouteRef by itself here\n     * as the callback will not fire for parameterized routes (i.e. /page/:id).\n     * So going from /page/1 to /page/2 would not fire this callback if we\n     * only listened for changes to matchedRouteRef.\n     */\n    watch(() => [route, matchedRouteRef.value], ([currentRoute, currentMatchedRouteRef]) => {\n      /**\n       * This callback checks whether or not a router outlet\n       * needs to respond to a change in the matched route.\n       * It handles a few cases:\n       * 1. The matched route is undefined. This means that\n       * the matched route is not applicable to this outlet.\n       * For example, a /settings route is not applicable\n       * to a /tabs/... route.\n       *\n       * Note: When going back to a tabs outlet from a non-tabs outlet,\n       * the tabs outlet should NOT attempt a page transition from the\n       * previous tab to the active tab. To do this we compare the current\n       * route with the previous route. Unfortunately, we cannot rely on the\n       * previous value provided by Vue in the watch callback. This is because\n       * when coming back to the tabs context, the previous matched route will\n       * be undefined (because nothing in the tabs context matches /settings)\n       * but the current matched route will be defined and so a transition\n       * will always occur.\n       *\n       * 2. The matched route is defined and is different than\n       * the previously matched route. This is the most\n       * common case such as when you go from /page1 to /page2.\n       *\n       * 3. The matched route is the same but the parameters are different.\n       * This is a special case for parameterized routes (i.e. /page/:id).\n       * When going from /page/1 to /page/2, the matched route object will\n       * be the same, but we still need to perform a page transition. To do this\n       * we check if the parameters are different (i.e. 1 vs 2). To avoid enumerating\n       * all of the keys in the params object, we check the url path to\n       * see if they are different after ensuring we are in a parameterized route.\n       */\n      if (currentMatchedRouteRef !== undefined) {\n        const matchedDifferentRoutes = currentMatchedRouteRef !== previousMatchedRouteRef;\n        const matchedDifferentParameterRoutes = currentRoute.matched[currentRoute.matched.length - 1] === currentMatchedRouteRef && currentRoute.path !== previousMatchedPath;\n        if (matchedDifferentRoutes || matchedDifferentParameterRoutes) {\n          setupViewItem(matchedRouteRef);\n        }\n      }\n      previousMatchedRouteRef = currentMatchedRouteRef;\n      previousMatchedPath = currentRoute.path;\n    },\n    /**\n     * Future versions of Vue may default watching nested\n     * reactive objects to \"deep: false\".\n     * We explicitly set this watcher to \"deep: true\" to\n     * account for that.\n     * https://github.com/vuejs/core/issues/9965#issuecomment-1875067499\n     */\n    {\n      deep: true\n    });\n    const canStart = () => {\n      const config = getConfig();\n      const swipeEnabled = config && config.get(\"swipeBackEnabled\", ionRouterOutlet.value.mode === \"ios\");\n      if (!swipeEnabled) return false;\n      const stack = viewStacks.getViewStack(id);\n      if (!stack || stack.length <= 1) return false;\n      /**\n       * We only want to outlet of the entering view\n       * to respond to this gesture, so check\n       * to make sure the view is in the outlet we want.\n       */\n      const routeInfo = ionRouter.getLeavingRouteInfo();\n      const enteringViewItem = viewStacks.findViewItemByRouteInfo({\n        pathname: routeInfo.pushedByRoute || \"\"\n      }, id);\n      return !!enteringViewItem;\n    };\n    const onStart = async () => {\n      const routeInfo = ionRouter.getLeavingRouteInfo();\n      const {\n        routerAnimation\n      } = routeInfo;\n      const enteringViewItem = viewStacks.findViewItemByRouteInfo({\n        pathname: routeInfo.pushedByRoute || \"\"\n      }, id);\n      const leavingViewItem = viewStacks.findViewItemByRouteInfo(routeInfo, id);\n      if (leavingViewItem) {\n        let animationBuilder = routerAnimation;\n        const enteringEl = enteringViewItem.ionPageElement;\n        const leavingEl = leavingViewItem.ionPageElement;\n        /**\n         * If we are going back from a page that\n         * was presented using a custom animation\n         * we should default to using that\n         * unless the developer explicitly\n         * provided another animation.\n         */\n        const customAnimation = enteringViewItem.routerAnimation;\n        if (animationBuilder === undefined && customAnimation !== undefined) {\n          animationBuilder = customAnimation;\n        }\n        leavingViewItem.routerAnimation = animationBuilder;\n        await transition(enteringEl, leavingEl, \"back\", ionRouter.canGoBack(2), true, animationBuilder);\n      }\n      return Promise.resolve();\n    };\n    const onEnd = shouldContinue => {\n      if (shouldContinue) {\n        skipTransition = true;\n        /**\n         * Use the same logic as clicking\n         * ion-back-button to determine where\n         * to go back to.\n         */\n        ionRouter.handleNavigateBack();\n      } else {\n        /**\n         * In the event that the swipe\n         * gesture was aborted, we should\n         * re-hide the page that was going to enter.\n         */\n        const routeInfo = ionRouter.getCurrentRouteInfo();\n        const enteringViewItem = viewStacks.findViewItemByRouteInfo({\n          pathname: routeInfo.pushedByRoute || \"\"\n        }, id);\n        enteringViewItem.ionPageElement.setAttribute(\"aria-hidden\", \"true\");\n        enteringViewItem.ionPageElement.classList.add(\"ion-page-hidden\");\n      }\n    };\n    watch(ionRouterOutlet, () => {\n      ionRouterOutlet.value.swipeHandler = {\n        canStart,\n        onStart,\n        onEnd\n      };\n    });\n    const transition = async (enteringEl, leavingEl, direction, showGoBack, progressAnimation, animationBuilder) => {\n      if (skipTransition) {\n        skipTransition = false;\n        return Promise.resolve(false);\n      }\n      if (enteringEl === leavingEl) {\n        return Promise.resolve(false);\n      }\n      enteringEl.classList.add(\"ion-page-invisible\");\n      const hasRootDirection = direction === undefined || direction === \"root\" || direction === \"none\";\n      const result = await ionRouterOutlet.value.commit(enteringEl, leavingEl, {\n        /**\n         * replace operations result in a direction of none.\n         * These typically do not have need animations, so we set\n         * the duration to 0. However, if a developer explicitly\n         * passes an animationBuilder, we should assume that\n         * they want an animation to be played even\n         * though it is a replace operation.\n         */\n        duration: hasRootDirection && animationBuilder === undefined ? 0 : undefined,\n        direction,\n        showGoBack,\n        progressAnimation,\n        animationBuilder\n      });\n      return result;\n    };\n    const handlePageTransition = async () => {\n      const routeInfo = ionRouter.getCurrentRouteInfo();\n      const {\n        routerDirection,\n        routerAction,\n        routerAnimation,\n        prevRouteLastPathname,\n        delta\n      } = routeInfo;\n      const enteringViewItem = viewStacks.findViewItemByRouteInfo(routeInfo, id);\n      let leavingViewItem = viewStacks.findLeavingViewItemByRouteInfo(routeInfo, id);\n      const enteringEl = enteringViewItem.ionPageElement;\n      /**\n       * All views that can be transitioned to must have\n       * an `<ion-page>` element for transitions and lifecycle\n       * methods to work properly.\n       */\n      if (enteringEl === undefined) {\n        console.warn(`[@ionic/vue Warning]: The view you are trying to render for path ${routeInfo.pathname} does not have the required <ion-page> component. Transitions and lifecycle methods may not work as expected.\n\nSee https://ionicframework.com/docs/vue/navigation#ionpage for more information.`);\n      }\n      if (enteringViewItem === leavingViewItem) return;\n      if (!leavingViewItem && prevRouteLastPathname) {\n        leavingViewItem = viewStacks.findViewItemByPathname(prevRouteLastPathname, id);\n      }\n      /**\n       * If the entering view is already\n       * visible, then no transition is needed.\n       * This is most common when navigating\n       * from a tabs page to a non-tabs page\n       * and then back to the tabs page.\n       * Even when the tabs context navigated away,\n       * the inner tabs page was still active.\n       * This also avoids an issue where\n       * the previous tabs page is incorrectly\n       * unmounted since it would automatically\n       * unmount the previous view.\n       *\n       * This should also only apply to entering and\n       * leaving items in the same router outlet (i.e.\n       * Tab1 and Tab2), otherwise this will\n       * return early for swipe to go back when\n       * going from a non-tabs page to a tabs page.\n       */\n      if (isViewVisible(enteringEl) && (leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement) !== undefined && !isViewVisible(leavingViewItem.ionPageElement)) {\n        return;\n      }\n      fireLifecycle(enteringViewItem.vueComponent, enteringViewItem.vueComponentRef, LIFECYCLE_WILL_ENTER);\n      if ((leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement) && enteringViewItem !== leavingViewItem) {\n        let animationBuilder = routerAnimation;\n        const leavingEl = leavingViewItem.ionPageElement;\n        fireLifecycle(leavingViewItem.vueComponent, leavingViewItem.vueComponentRef, LIFECYCLE_WILL_LEAVE);\n        /**\n         * If we are going back from a page that\n         * was presented using a custom animation\n         * we should default to using that\n         * unless the developer explicitly\n         * provided another animation.\n         */\n        const customAnimation = enteringViewItem.routerAnimation;\n        if (animationBuilder === undefined && routerDirection === \"back\" && customAnimation !== undefined) {\n          animationBuilder = customAnimation;\n        }\n        leavingViewItem.routerAnimation = animationBuilder;\n        await transition(enteringEl, leavingEl, routerDirection, !!routeInfo.pushedByRoute, false, animationBuilder);\n        leavingEl.classList.add(\"ion-page-hidden\");\n        leavingEl.setAttribute(\"aria-hidden\", \"true\");\n        const usingLinearNavigation = viewStacks.size() === 1;\n        if (routerAction === \"replace\") {\n          leavingViewItem.mount = false;\n          leavingViewItem.ionPageElement = undefined;\n          leavingViewItem.ionRoute = false;\n        } else if (!(routerAction === \"push\" && routerDirection === \"forward\")) {\n          const shouldLeavingViewBeRemoved = routerDirection !== \"none\" && leavingViewItem && enteringViewItem !== leavingViewItem;\n          if (shouldLeavingViewBeRemoved) {\n            leavingViewItem.mount = false;\n            leavingViewItem.ionPageElement = undefined;\n            leavingViewItem.ionRoute = false;\n            /**\n             * router.go() expects navigation to be\n             * linear. If an app is using multiple stacks then\n             * it is not using linear navigation. As a result, router.go()\n             * will not give the results that developers are expecting.\n             */\n            if (usingLinearNavigation) {\n              viewStacks.unmountLeavingViews(id, enteringViewItem, delta);\n            }\n          }\n        } else if (usingLinearNavigation) {\n          viewStacks.mountIntermediaryViews(id, leavingViewItem, delta);\n        }\n        fireLifecycle(leavingViewItem.vueComponent, leavingViewItem.vueComponentRef, LIFECYCLE_DID_LEAVE);\n      } else {\n        /**\n         * If there is no leaving element, just show\n         * the entering element. Wrap it in an raf\n         * in case ion-content's fullscreen callback\n         * is running. Otherwise we'd have a flicker.\n         */\n        requestAnimationFrame(() => enteringEl.classList.remove(\"ion-page-invisible\"));\n      }\n      fireLifecycle(enteringViewItem.vueComponent, enteringViewItem.vueComponentRef, LIFECYCLE_DID_ENTER);\n      components.value = viewStacks.getChildrenToRender(id);\n    };\n    const setupViewItem = matchedRouteRef => {\n      const firstMatchedRoute = route.matched[0];\n      if (!parentOutletPath) {\n        parentOutletPath = firstMatchedRoute.path;\n      }\n      /**\n       * If no matched route, do not do anything in this outlet.\n       * If there is a match, but it the first matched path\n       * is not the root path for this outlet, then this view\n       * change needs to be rendered in a different outlet.\n       * We also add an exception for when the matchedRouteRef is\n       * equal to the first matched route (i.e. the base router outlet).\n       * This logic is mainly to help nested outlets/multi-tab\n       * setups work better.\n       */\n      if (!matchedRouteRef.value || matchedRouteRef.value !== firstMatchedRoute && firstMatchedRoute.path !== parentOutletPath) {\n        return;\n      }\n      const currentRoute = ionRouter.getCurrentRouteInfo();\n      let enteringViewItem = viewStacks.findViewItemByRouteInfo(currentRoute, id);\n      if (!enteringViewItem) {\n        enteringViewItem = viewStacks.createViewItem(id, matchedRouteRef.value.components.default, matchedRouteRef.value, currentRoute);\n        viewStacks.add(enteringViewItem);\n      }\n      if (!enteringViewItem.mount) {\n        enteringViewItem.mount = true;\n        enteringViewItem.registerCallback = () => {\n          handlePageTransition();\n          enteringViewItem.registerCallback = undefined;\n        };\n      } else {\n        handlePageTransition();\n      }\n      components.value = viewStacks.getChildrenToRender(id);\n    };\n    if (matchedRouteRef.value) {\n      setupViewItem(matchedRouteRef);\n    }\n    /**\n     * Remove stack data for this outlet\n     * when outlet is destroyed otherwise\n     * we will see cached view data.\n     */\n    onUnmounted(() => viewStacks.clear(id));\n    const registerIonPage = (viewItem, ionPageEl) => {\n      const oldIonPageEl = viewItem.ionPageElement;\n      viewStacks.registerIonPage(viewItem, ionPageEl);\n      /**\n       * If there is a registerCallback,\n       * then this component is being registered\n       * as a result of a navigation change.\n       */\n      if (viewItem.registerCallback) {\n        /**\n         * Page should be hidden initially\n         * to avoid flickering.\n         */\n        ionPageEl.classList.add(\"ion-page-invisible\");\n        viewItem.registerCallback();\n        /**\n         * If there is no registerCallback, then\n         * this component is likely being re-registered\n         * as a result of a hot module replacement.\n         * We need to see if the oldIonPageEl has\n         * .ion-page-invisible. If it does not then we\n         * need to remove it from the new ionPageEl otherwise\n         * the page will be hidden when it is replaced.\n         */\n      } else if (oldIonPageEl && !oldIonPageEl.classList.contains(\"ion-page-invisible\")) {\n        ionPageEl.classList.remove(\"ion-page-invisible\");\n      }\n    };\n    return {\n      id,\n      components,\n      injectedRoute,\n      ionRouterOutlet,\n      registerIonPage\n    };\n  },\n  render() {\n    const {\n      components,\n      registerIonPage,\n      injectedRoute\n    } = this;\n    return h(\"ion-router-outlet\", {\n      ref: \"ionRouterOutlet\"\n    }, components && components.map(c => {\n      var _a, _b;\n      let props = {\n        ref: c.vueComponentRef,\n        key: c.pathname,\n        registerIonPage: ionPageEl => registerIonPage(c, ionPageEl)\n      };\n      /**\n       * IonRouterOutlet does not support named outlets.\n       */\n      const routePropsOption = (_b = (_a = c.matchedRoute) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.default;\n      /**\n       * Since IonRouterOutlet renders multiple components,\n       * each render will cause all props functions to be\n       * called again. As a result, we need to cache the function\n       * result and provide it on each render so that the props\n       * are not lost when navigating from and back to a page.\n       * When a component is destroyed and re-created, the\n       * function is called again.\n       */\n      const getPropsFunctionResult = () => {\n        var _a;\n        const cachedPropsResult = (_a = c.vueComponentData) === null || _a === void 0 ? void 0 : _a.propsFunctionResult;\n        if (cachedPropsResult) {\n          return cachedPropsResult;\n        } else {\n          const propsFunctionResult = routePropsOption(injectedRoute);\n          c.vueComponentData = Object.assign(Object.assign({}, c.vueComponentData), {\n            propsFunctionResult\n          });\n          return propsFunctionResult;\n        }\n      };\n      const routeProps = routePropsOption ? routePropsOption === true ? c.params : typeof routePropsOption === \"function\" ? getPropsFunctionResult() : routePropsOption : null;\n      props = Object.assign(Object.assign({}, props), routeProps);\n      return h(c.vueComponent, props);\n    }));\n  }\n});\nconst IonTabButton = /*@__PURE__*/defineComponent({\n  name: \"IonTabButton\",\n  props: {\n    _getTabState: {\n      type: Function,\n      default: () => {\n        return {};\n      }\n    },\n    disabled: Boolean,\n    download: String,\n    href: String,\n    rel: String,\n    layout: String,\n    selected: Boolean,\n    tab: String,\n    target: String,\n    _onClick: {\n      type: Function,\n      required: false\n    }\n  },\n  setup(props, {\n    slots\n  }) {\n    defineCustomElement$1f();\n    // TODO(FW-2969): type\n    const ionRouter = inject(\"navManager\", null);\n    const onClick = ev => {\n      if (ev.cancelable) {\n        ev.preventDefault();\n      }\n      /**\n       * Keeping track of the originalHref\n       * (i.e. /tabs/tab1) lets us redirect\n       * users back to a child page using currentHref\n       * (i.e. /tabs/tab1/child).\n       */\n      const {\n        tab,\n        href,\n        _getTabState\n      } = props;\n      const tabState = _getTabState();\n      const hasRouterOutlet = tabState.hasRouterOutlet;\n      const tappedTab = tabState.tabs[tab] || {};\n      const originalHref = tappedTab.originalHref || href;\n      /**\n       * If the router outlet is not defined, then the tabs is being used\n       * as a basic tab navigation without the router. In this case, we\n       * don't want to update the href else the URL will change.\n       */\n      const currentHref = hasRouterOutlet ? tappedTab.currentHref || href : \"\";\n      const prevActiveTab = tabState.activeTab;\n      if (!hasRouterOutlet && props._onClick) {\n        props._onClick(new CustomEvent(\"ionTabButtonClick\", {\n          detail: {\n            href: currentHref,\n            selected: tab === prevActiveTab,\n            tab\n          }\n        }));\n      }\n      /**\n       * If we are still on the same\n       * tab as before, but the base href\n       * does not equal the current href,\n       * then we must be on a child page and\n       * should direct users back to the root\n       * of the tab.\n       */\n      if (ionRouter !== null) {\n        if (prevActiveTab === tab) {\n          if (originalHref !== currentHref) {\n            ionRouter.resetTab(tab);\n          }\n        } else {\n          ionRouter.changeTab(tab, currentHref);\n        }\n      }\n    };\n    return () => {\n      return h(\"ion-tab-button\", Object.assign({\n        onClick\n      }, props), slots.default && slots.default());\n    };\n  }\n});\nconst WILL_CHANGE = \"ionTabsWillChange\";\nconst DID_CHANGE = \"ionTabsDidChange\";\n/**\n * Vue 3.2.38 fixed an issue where Web Component\n * names are respected using kebab case instead of pascal case.\n * As a result, we need to account for both here since we support\n * versions of Vue < 3.2.38.\n */\n// TODO FW-5904\nconst isRouterOutlet = node => {\n  return node.type && (node.type.name === \"IonRouterOutlet\" || node.type === \"ion-router-outlet\");\n};\nconst isTab = node => {\n  // The `ion-tab` component was created with the `v-for` directive.\n  if (node.type === Fragment) {\n    if (Array.isArray(node.children)) {\n      return node.children.some(child => isVNode(child) && isTab(child));\n    }\n    return false; // In case the fragment has no children.\n  }\n  return node.type && (node.type.name === \"ion-tab\" || node.type === IonTab);\n};\nconst IonTabs = /*@__PURE__*/defineComponent({\n  name: \"IonTabs\",\n  emits: [WILL_CHANGE, DID_CHANGE],\n  data() {\n    return {\n      hasRouterOutlet: false\n    };\n  },\n  setup(props, {\n    slots,\n    emit\n  }) {\n    const slottedContent = slots.default && slots.default();\n    let routerOutlet = undefined;\n    if (slottedContent && slottedContent.length > 0) {\n      /**\n       * Developers must pass an ion-router-outlet\n       * inside of ion-tabs if they want to use\n       * the history stack or URL updates associated\n       * with the router.\n       */\n      routerOutlet = slottedContent.find(child => isRouterOutlet(child));\n    }\n    /**\n     * Tab bar can be used as a standalone component,\n     * so it cannot be modified directly through\n     * IonTabs. Instead, data will be passed through\n     * the provide/inject.\n     */\n    provide(\"tabBarData\", shallowRef({\n      hasRouterOutlet: !!routerOutlet,\n      _tabsWillChange: tab => emit(WILL_CHANGE, {\n        tab\n      }),\n      _tabsDidChange: tab => emit(DID_CHANGE, {\n        tab\n      })\n    }));\n    return {\n      props,\n      slots,\n      emit\n    };\n  },\n  mounted() {\n    /**\n     * `defineCustomElement` must be called in the `mounted` hook\n     * to ensure that the custom element is defined after the\n     * component has been fully rendered and initialized.\n     * This prevents issues with undefined properties, like\n     * `selectedTab` from core, which may occur if the custom\n     * element is defined too early in the component's lifecycle.\n     */\n    defineCustomElement$1g();\n  },\n  render() {\n    const {\n      slots,\n      props\n    } = this;\n    const slottedContent = slots.default && slots.default();\n    let routerOutlet = undefined;\n    let hasTab = false;\n    if (slottedContent && slottedContent.length > 0) {\n      /**\n       * Developers must pass an ion-router-outlet\n       * inside of ion-tabs if they want to use\n       * the history stack or URL updates associated\n       * with the router.\n       */\n      routerOutlet = slottedContent.find(child => isRouterOutlet(child));\n      /**\n       * Developers must pass at least one ion-tab\n       * inside of ion-tabs if they want to use a\n       * basic tab-based navigation without the\n       * history stack or URL updates associated\n       * with the router.\n       */\n      hasTab = slottedContent.some(child => isTab(child));\n    }\n    if (!routerOutlet && !hasTab) {\n      throw new Error(\"IonTabs must contain an IonRouterOutlet or an IonTab.\");\n    }\n    if (routerOutlet && hasTab) {\n      throw new Error(\"IonTabs cannot contain an IonRouterOutlet and IonTab at the same time.\");\n    }\n    if (hasTab) {\n      return h(\"ion-tabs\", Object.assign({}, props), slottedContent);\n    }\n    /**\n     * TODO(ROU-11056)\n     *\n     * Vue handles the error case for when there is no\n     * associated page matching the tab `href`.\n     *\n     * More investigation is needed to determine if we\n     * override the error handling and provide our own\n     * error message.\n     */\n    return h(\"ion-tabs\", {\n      style: {\n        display: \"flex\",\n        position: \"absolute\",\n        top: \"0\",\n        left: \"0\",\n        right: \"0\",\n        bottom: \"0\",\n        \"flex-direction\": \"column\",\n        width: \"100%\",\n        height: \"100%\",\n        contain: \"layout size style\",\n        \"z-index\": \"0\"\n      }\n    }, slottedContent);\n  }\n});\nconst isTabButton = child => {\n  var _a;\n  return ((_a = child.type) === null || _a === void 0 ? void 0 : _a.name) === \"IonTabButton\";\n};\nconst getTabs = nodes => {\n  let tabs = [];\n  nodes.forEach(node => {\n    if (isTabButton(node)) {\n      tabs.push(node);\n    } else if (Array.isArray(node.children) && node.children.length > 1) {\n      const childTabs = getTabs(node.children);\n      tabs = [...tabs, ...childTabs];\n    }\n  });\n  return tabs;\n};\nconst IonTabBar = defineComponent({\n  name: \"IonTabBar\",\n  data() {\n    return {\n      tabState: {\n        activeTab: undefined,\n        tabs: {},\n        /**\n         * Passing this prop to each tab button\n         * lets it be aware of the presence of\n         * the router outlet.\n         */\n        hasRouterOutlet: false\n      },\n      tabVnodes: [],\n      /* eslint-disable @typescript-eslint/no-empty-function */\n      _tabsWillChange: {\n        type: Function,\n        default: () => {}\n      },\n      _tabsDidChange: {\n        type: Function,\n        default: () => {}\n      }\n      /* eslint-enable @typescript-eslint/no-empty-function */\n    };\n  },\n  updated() {\n    this.setupTabState(inject(\"navManager\", null));\n  },\n  methods: {\n    setupTabState(ionRouter) {\n      const hasRouterOutlet = this.$data.tabState.hasRouterOutlet;\n      /**\n       * For each tab, we need to keep track of its\n       * base href as well as any child page that\n       * is active in its stack so that when we go back\n       * to a tab from another tab, we can correctly\n       * show any child pages if necessary.\n       */\n      const tabState = this.$data.tabState;\n      const currentInstance = getCurrentInstance();\n      const tabs = this.$data.tabVnodes = getTabs(currentInstance.subTree.children || []);\n      tabs.forEach(child => {\n        tabState.tabs[child.props.tab] = {\n          originalHref: child.props.href,\n          currentHref: child.props.href,\n          ref: child\n        };\n        /**\n         * Passing this prop to each tab button\n         * lets it be aware of the state that\n         * ion-tab-bar is managing for it.\n         */\n        child.component.props._getTabState = () => tabState;\n        /**\n         * If the router outlet is not defined, then the tabs are being used\n         * as a basic tab navigation without the router. In this case, the\n         * tabs will not emit the `ionTabsDidChange` and `ionTabsWillChange`\n         * events through the `checkActiveTab` method. Instead, we need to\n         * handle those events through the tab buttons.\n         */\n        if (!hasRouterOutlet) {\n          child.component.props._onClick = event => {\n            this.handleIonTabButtonClick(event);\n          };\n        }\n      });\n      this.checkActiveTab(ionRouter);\n    },\n    /**\n     * This method is called upon setup and when the\n     * history changes. It checks the current route\n     * and updates the active tab accordingly.\n     *\n     * History changes only occur when the router\n     * outlet is present. Due to this, the\n     * `ionTabsDidChange` and `ionTabsWillChange`\n     * events are only emitted when the router\n     * outlet is present. A different approach must\n     * be taken for tabs without a router outlet.\n     *\n     * @param ionRouter\n     */\n    checkActiveTab(ionRouter) {\n      const hasRouterOutlet = this.$data.tabState.hasRouterOutlet;\n      const currentRoute = ionRouter === null || ionRouter === void 0 ? void 0 : ionRouter.getCurrentRouteInfo();\n      const childNodes = this.$data.tabVnodes;\n      const {\n        tabs,\n        activeTab: prevActiveTab\n      } = this.$data.tabState;\n      const tabKeys = Object.keys(tabs);\n      let activeTab = tabKeys.find(key => {\n        const href = tabs[key].originalHref;\n        return currentRoute === null || currentRoute === void 0 ? void 0 : currentRoute.pathname.startsWith(href);\n      });\n      /**\n       * Tabs is being used as a basic tab navigation,\n       * so we need to set the first tab as active since\n       * `checkActiveTab` will not be called after setup.\n       */\n      if (!activeTab && !hasRouterOutlet) {\n        activeTab = tabKeys[0];\n      }\n      /**\n       * For each tab, check to see if the\n       * base href has changed. If so, update\n       * it in the tabs state.\n       */\n      childNodes.forEach(child => {\n        const tab = tabs[child.props.tab];\n        if (!tab || tab.originalHref !== child.props.href) {\n          tabs[child.props.tab] = {\n            originalHref: child.props.href,\n            currentHref: child.props.href,\n            ref: child\n          };\n        }\n      });\n      if (activeTab && prevActiveTab) {\n        const prevHref = this.$data.tabState.tabs[prevActiveTab].currentHref;\n        /**\n         * If the tabs change or the url changes,\n         * update the currentHref for the active tab.\n         * Ex: url changes from /tabs/tab1 --> /tabs/tab1/child\n         * If we went to tab2 then back to tab1, we should\n         * land on /tabs/tab1/child instead of /tabs/tab1.\n         */\n        if (activeTab !== prevActiveTab || prevHref !== (currentRoute === null || currentRoute === void 0 ? void 0 : currentRoute.pathname)) {\n          /**\n           * By default the search is `undefined` in Ionic Vue,\n           * but Vue Router can set the search to the empty string.\n           * We check for truthy here because empty string is falsy\n           * and currentRoute.search cannot ever be a boolean.\n           */\n          const search = (currentRoute === null || currentRoute === void 0 ? void 0 : currentRoute.search) ? `?${currentRoute.search}` : \"\";\n          tabs[activeTab] = Object.assign(Object.assign({}, tabs[activeTab]), {\n            currentHref: (currentRoute === null || currentRoute === void 0 ? void 0 : currentRoute.pathname) + search\n          });\n        }\n        /**\n         * If navigating back and the tabs change,\n         * set the previous tab back to its original href.\n         */\n        if ((currentRoute === null || currentRoute === void 0 ? void 0 : currentRoute.routerAction) === \"pop\" && activeTab !== prevActiveTab) {\n          tabs[prevActiveTab] = Object.assign(Object.assign({}, tabs[prevActiveTab]), {\n            currentHref: tabs[prevActiveTab].originalHref\n          });\n        }\n      }\n      this.tabSwitch(activeTab, ionRouter);\n    },\n    handleIonTabButtonClick(event) {\n      const activeTab = event.detail.tab;\n      this.tabSwitch(activeTab);\n    },\n    tabSwitch(activeTab, ionRouter) {\n      const hasRouterOutlet = this.$data.tabState.hasRouterOutlet;\n      const childNodes = this.$data.tabVnodes;\n      const {\n        activeTab: prevActiveTab\n      } = this.$data.tabState;\n      const tabState = this.$data.tabState;\n      const activeChild = childNodes.find(child => {\n        var _a;\n        return isTabButton(child) && ((_a = child.props) === null || _a === void 0 ? void 0 : _a.tab) === activeTab;\n      });\n      const tabBar = this.$refs.ionTabBar;\n      const tabDidChange = activeTab !== prevActiveTab;\n      if (tabBar) {\n        if (activeChild) {\n          tabDidChange && this.$data._tabsWillChange(activeTab);\n          if (hasRouterOutlet && ionRouter !== null) {\n            ionRouter.handleSetCurrentTab(activeTab);\n          }\n          tabBar.selectedTab = tabState.activeTab = activeTab;\n          tabDidChange && this.$data._tabsDidChange(activeTab);\n        } else {\n          /**\n           * When going to a tab that does\n           * not have an associated ion-tab-button\n           * we need to remove the selected state from\n           * the old tab.\n           */\n          tabBar.selectedTab = tabState.activeTab = \"\";\n        }\n      }\n    }\n  },\n  mounted() {\n    const ionRouter = inject(\"navManager\", null);\n    /**\n     * Tab bar can be used as a standalone component,\n     * so it cannot be modified directly through\n     * IonTabs. Instead, data will be passed through\n     * the provide/inject.\n     */\n    const tabBarData = inject(\"tabBarData\");\n    this.$data.tabState.hasRouterOutlet = tabBarData.value.hasRouterOutlet;\n    this.$data._tabsWillChange = tabBarData.value._tabsWillChange;\n    this.$data._tabsDidChange = tabBarData.value._tabsDidChange;\n    this.setupTabState(ionRouter);\n    ionRouter === null || ionRouter === void 0 ? void 0 : ionRouter.registerHistoryChangeListener(() => this.checkActiveTab(ionRouter));\n  },\n  setup(_, {\n    slots\n  }) {\n    defineCustomElement$1h();\n    return () => {\n      return h(\"ion-tab-bar\", {\n        ref: \"ionTabBar\"\n      }, slots.default && slots.default());\n    };\n  }\n});\nconst userComponents = shallowRef([]);\nconst IonApp = /*@__PURE__*/defineComponent((_, {\n  attrs,\n  slots\n}) => {\n  defineCustomElement$1i();\n  return () => {\n    return h(\"ion-app\", Object.assign({\n      name: \"IonApp\"\n    }, attrs), [slots.default && slots.default(), ...userComponents.value]);\n  };\n}, {\n  name: \"IonApp\"\n});\n/**\n * When rendering user components inside of\n * ion-modal, or ion-popover the component\n * needs to be created inside of the current application\n * context otherwise libraries such as vue-i18n or vuex\n * will not work properly.\n *\n * `userComponents` renders teleported components as children\n * of `ion-app` within the current application context.\n */\nconst addTeleportedUserComponent = component => {\n  userComponents.value = [...userComponents.value, component];\n};\nconst removeTeleportedUserComponent = component => {\n  userComponents.value = userComponents.value.filter(cmp => cmp !== component);\n};\nconst VueDelegate = (addFn = addTeleportedUserComponent, removeFn = removeTeleportedUserComponent) => {\n  // `h` doesn't provide a type for the component argument\n  const refMap = new WeakMap();\n  // TODO(FW-2969): types\n  const attachViewToDom = (parentElement, componentOrTagName, componentProps = {}, classes) => {\n    const div = document.createElement(\"div\");\n    classes && div.classList.add(...classes);\n    parentElement.appendChild(div);\n    const hostComponent = h(Teleport, {\n      to: div\n    }, h(componentOrTagName, Object.assign({}, componentProps)));\n    /**\n     * Ionic Framework will use what is returned from `attachViewToDom`\n     * as the `component` argument in `removeViewFromDom`.\n     *\n     * We will store a reference to the div element and the host component,\n     * so we can later look-up and unmount the correct instance.\n     */\n    refMap.set(div, hostComponent);\n    addFn(hostComponent);\n    return Promise.resolve(div);\n  };\n  const removeViewFromDom = (_container, component) => {\n    const hostComponent = refMap.get(component);\n    hostComponent && removeFn(hostComponent);\n    return Promise.resolve();\n  };\n  return {\n    attachViewToDom,\n    removeViewFromDom\n  };\n};\nconst IonNav = /*@__PURE__*/defineComponent(props => {\n  defineCustomElement$1j();\n  const views = shallowRef([]);\n  /**\n   * Allows us to create the component\n   * within the Vue application context.\n   */\n  const addView = component => views.value = [...views.value, component];\n  const removeView = component => views.value = views.value.filter(cmp => cmp !== component);\n  const delegate = VueDelegate(addView, removeView);\n  return () => {\n    return h(\"ion-nav\", Object.assign(Object.assign({}, props), {\n      delegate\n    }), views.value);\n  };\n}, {\n  name: \"IonNav\",\n  /**\n   * The default values follow what is defined at\n   * https://ionicframework.com/docs/api/nav#properties\n   * otherwise the default values on the Web Component\n   * may be overridden. For example, if the default animated value\n   * is not `true` below, then Vue would default the prop to `false`\n   * which would override the Web Component default of `true`.\n   */\n  props: {\n    animated: {\n      type: Boolean,\n      default: true\n    },\n    animation: {\n      type: Function,\n      default: undefined\n    },\n    root: {\n      type: [Function, Object, String],\n      default: undefined\n    },\n    rootParams: {\n      type: Object,\n      default: undefined\n    },\n    swipeGesture: {\n      type: Boolean,\n      default: undefined\n    }\n  }\n});\nconst IonIcon = /*@__PURE__*/defineComponent((props, {\n  slots\n}) => {\n  defineCustomElement$1k();\n  return () => {\n    var _a, _b;\n    const {\n      icon,\n      ios,\n      md,\n      mode\n    } = props;\n    let iconToUse;\n    const config = getConfig();\n    const iconMode = mode || (config === null || config === void 0 ? void 0 : config.get(\"mode\"));\n    if (ios || md) {\n      if (iconMode === \"ios\") {\n        iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;\n      } else {\n        iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;\n      }\n    } else {\n      iconToUse = icon;\n    }\n    return h(\"ion-icon\", Object.assign(Object.assign({}, props), {\n      icon: iconToUse\n    }), slots);\n  };\n}, {\n  name: \"IonIcon\",\n  props: {\n    color: {\n      type: String\n    },\n    flipRtl: {\n      type: Boolean\n    },\n    icon: {\n      type: String\n    },\n    ios: {\n      type: String\n    },\n    lazy: {\n      type: Boolean\n    },\n    md: {\n      type: String\n    },\n    mode: {\n      type: String\n    },\n    name: {\n      type: String\n    },\n    size: {\n      type: String\n    },\n    src: {\n      type: String\n    }\n  }\n});\nconst EMPTY_PROP = Symbol();\nconst DEFAULT_EMPTY_PROP = {\n  default: EMPTY_PROP\n};\nconst defineOverlayContainer = (name, defineCustomElement, componentProps = [], hasDelegateHost, controller) => {\n  const createControllerComponent = options => {\n    return defineComponent((props, {\n      slots,\n      emit\n    }) => {\n      const eventListeners = [{\n        componentEv: `${name}WillPresent`,\n        frameworkEv: \"willPresent\"\n      }, {\n        componentEv: `${name}DidPresent`,\n        frameworkEv: \"didPresent\"\n      }, {\n        componentEv: `${name}WillDismiss`,\n        frameworkEv: \"willDismiss\"\n      }, {\n        componentEv: `${name}DidDismiss`,\n        frameworkEv: \"didDismiss\"\n      }];\n      if (defineCustomElement !== undefined) {\n        defineCustomElement();\n      }\n      const overlay = ref();\n      const onVnodeMounted = async () => {\n        const isOpen = props.isOpen;\n        isOpen && (await present(props));\n      };\n      const onVnodeUpdated = async (node, prevNode) => {\n        const isOpen = node.props.isOpen;\n        const prevIsOpen = prevNode.props.isOpen;\n        /**\n         * Do not do anything if this prop\n         * did not change.\n         */\n        if (isOpen === prevIsOpen) return;\n        if (isOpen) {\n          await present(props);\n        } else {\n          await dismiss();\n        }\n      };\n      const onVnodeBeforeUnmount = async () => {\n        await dismiss();\n      };\n      const dismiss = async () => {\n        if (!overlay.value) return;\n        await overlay.value;\n        overlay.value = overlay.value.dismiss();\n        await overlay.value;\n        overlay.value = undefined;\n      };\n      const present = async props => {\n        var _a;\n        /**\n         * Do not open another instance\n         * if one is already opened.\n         */\n        if (overlay.value) {\n          await overlay.value;\n        }\n        if ((_a = overlay.value) === null || _a === void 0 ? void 0 : _a.present) {\n          await overlay.value.present();\n          return;\n        }\n        const restOfProps = {};\n        /**\n         * We can use Object.entries here\n         * to avoid the hasOwnProperty check,\n         * but that would require 2 iterations\n         * where as this only requires 1.\n         */\n        for (const key in props) {\n          const value = props[key];\n          if (Object.prototype.hasOwnProperty.call(props, key) && value !== EMPTY_PROP) {\n            restOfProps[key] = value;\n          }\n        }\n        /**\n         * These are getting passed as props.\n         * Potentially a Vue bug with Web Components?\n         */\n        delete restOfProps.onWillPresent;\n        delete restOfProps.onDidPresent;\n        delete restOfProps.onWillDismiss;\n        delete restOfProps.onDidDismiss;\n        const component = slots.default && slots.default()[0];\n        overlay.value = controller.create(Object.assign(Object.assign({}, restOfProps), {\n          component\n        }));\n        overlay.value = await overlay.value;\n        eventListeners.forEach(eventListener => {\n          overlay.value.addEventListener(eventListener.componentEv, () => {\n            emit(eventListener.frameworkEv);\n          });\n        });\n        await overlay.value.present();\n      };\n      return () => {\n        return h(\"div\", {\n          style: {\n            display: \"none\"\n          },\n          onVnodeMounted,\n          onVnodeUpdated,\n          onVnodeBeforeUnmount,\n          isOpen: props.isOpen === true\n        });\n      };\n    }, options);\n  };\n  const createInlineComponent = options => {\n    return defineComponent((props, {\n      slots,\n      emit\n    }) => {\n      if (defineCustomElement !== undefined) {\n        defineCustomElement();\n      }\n      const isOpen = ref(false);\n      const elementRef = ref();\n      onMounted(() => {\n        // Convert name from kebab-case to camelCase\n        const componentName = name.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());\n        elementRef.value.addEventListener(\"ionMount\", ev => {\n          emit(\"ionMount\", ev);\n          emit(componentName + \"IonMount\", ev);\n          isOpen.value = true;\n        });\n        elementRef.value.addEventListener(\"willPresent\", ev => {\n          emit(\"willPresent\", ev);\n          emit(componentName + \"WillPresent\", ev);\n          isOpen.value = true;\n        });\n        elementRef.value.addEventListener(\"didDismiss\", ev => {\n          emit(\"didDismiss\", ev);\n          emit(componentName + \"DidDismiss\", ev);\n          isOpen.value = false;\n        });\n        elementRef.value.addEventListener(\"willDismiss\", ev => {\n          emit(\"willDismiss\", ev);\n          emit(componentName + \"WillDismiss\", ev);\n        });\n        elementRef.value.addEventListener(\"didPresent\", ev => {\n          emit(\"didPresent\", ev);\n          emit(componentName + \"DidPresent\", ev);\n        });\n      });\n      return () => {\n        const restOfProps = {};\n        /**\n         * We can use Object.entries here\n         * to avoid the hasOwnProperty check,\n         * but that would require 2 iterations\n         * where as this only requires 1.\n         */\n        for (const key in props) {\n          const value = props[key];\n          if (Object.prototype.hasOwnProperty.call(props, key) && value !== EMPTY_PROP) {\n            restOfProps[key] = value;\n          }\n        }\n        /**\n         * Some overlays need a wrapper element so content\n         * takes up the full size of the parent overlay.\n         */\n        const renderChildren = () => {\n          if (hasDelegateHost) {\n            return h(\"div\", {\n              className: \"ion-delegate-host ion-page\"\n            }, slots);\n          }\n          return slots;\n        };\n        return h(name, Object.assign(Object.assign({}, restOfProps), {\n          ref: elementRef\n        }),\n        /**\n         * When binding keepContentsMounted as an attribute\n         * i.e. <ion-modal keep-contents-mounted></ion-modal>\n         * the value of the prop will be the empty string which is\n         * why we still call renderChildren() in that case.\n         */\n        isOpen.value || restOfProps.keepContentsMounted || restOfProps.keepContentsMounted === \"\" ? renderChildren() : undefined);\n      };\n    }, options);\n  };\n  const options = {\n    name,\n    props: Object.assign({\n      isOpen: DEFAULT_EMPTY_PROP\n    }, componentProps.reduce((acc, prop) => {\n      acc[prop] = DEFAULT_EMPTY_PROP;\n      return acc;\n    }, {})),\n    emits: typeof controller !== \"undefined\" ? [\"willPresent\", \"didPresent\", \"willDismiss\", \"didDismiss\"] : undefined\n  };\n  return controller !== undefined ? createControllerComponent(options) : createInlineComponent(options);\n};\n\n/**\n * This is an autogenerated file created by 'scripts/copy-overlays.js'.\n * Changes made to this file will be overwritten on build.\n */\nconst IonActionSheet = /*@__PURE__*/defineOverlayContainer('ion-action-sheet', defineCustomElement$1l, ['animated', 'backdropDismiss', 'buttons', 'cssClass', 'enterAnimation', 'header', 'htmlAttributes', 'isOpen', 'keyboardClose', 'leaveAnimation', 'mode', 'subHeader', 'translucent', 'trigger']);\nconst IonAlert = /*@__PURE__*/defineOverlayContainer('ion-alert', defineCustomElement$1m, ['animated', 'backdropDismiss', 'buttons', 'cssClass', 'enterAnimation', 'header', 'htmlAttributes', 'inputs', 'isOpen', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'subHeader', 'translucent', 'trigger']);\nconst IonLoading = /*@__PURE__*/defineOverlayContainer('ion-loading', defineCustomElement$1n, ['animated', 'backdropDismiss', 'cssClass', 'duration', 'enterAnimation', 'htmlAttributes', 'isOpen', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'showBackdrop', 'spinner', 'translucent', 'trigger']);\nconst IonModal = /*@__PURE__*/defineOverlayContainer('ion-modal', defineCustomElement$1o, ['animated', 'backdropBreakpoint', 'backdropDismiss', 'breakpoints', 'canDismiss', 'enterAnimation', 'expandToScroll', 'focusTrap', 'handle', 'handleBehavior', 'htmlAttributes', 'initialBreakpoint', 'isOpen', 'keepContentsMounted', 'keyboardClose', 'leaveAnimation', 'mode', 'presentingElement', 'showBackdrop', 'trigger'], true);\nconst IonPickerLegacy = /*@__PURE__*/defineOverlayContainer('ion-picker-legacy', defineCustomElement$1p, ['animated', 'backdropDismiss', 'buttons', 'columns', 'cssClass', 'duration', 'enterAnimation', 'htmlAttributes', 'isOpen', 'keyboardClose', 'leaveAnimation', 'mode', 'showBackdrop', 'trigger']);\nconst IonPopover = /*@__PURE__*/defineOverlayContainer('ion-popover', defineCustomElement$1q, ['alignment', 'animated', 'arrow', 'backdropDismiss', 'component', 'componentProps', 'dismissOnSelect', 'enterAnimation', 'event', 'focusTrap', 'htmlAttributes', 'isOpen', 'keepContentsMounted', 'keyboardClose', 'leaveAnimation', 'mode', 'reference', 'showBackdrop', 'side', 'size', 'translucent', 'trigger', 'triggerAction']);\nconst IonToast = /*@__PURE__*/defineOverlayContainer('ion-toast', defineCustomElement$1r, ['animated', 'buttons', 'color', 'cssClass', 'duration', 'enterAnimation', 'header', 'htmlAttributes', 'icon', 'isOpen', 'keyboardClose', 'layout', 'leaveAnimation', 'message', 'mode', 'position', 'positionAnchor', 'swipeGesture', 'translucent', 'trigger']);\n\n// TODO(FW-2969): types\n/**\n * Wrap the controllers export from @ionic/core\n * register the underlying Web Component and\n * (optionally) provide a framework delegate.\n */\nconst createController = (defineCustomElement, oldController, useDelegate = false) => {\n  const delegate = useDelegate ? VueDelegate() : undefined;\n  const oldCreate = oldController.create.bind(oldController);\n  oldController.create = options => {\n    defineCustomElement();\n    return oldCreate(Object.assign(Object.assign({}, options), {\n      delegate\n    }));\n  };\n  return oldController;\n};\nconst modalController = /*@__PURE__*/createController(defineCustomElement$1o, modalController$1, true);\nconst popoverController = /*@__PURE__*/createController(defineCustomElement$1q, popoverController$1, true);\nconst alertController = /*@__PURE__*/createController(defineCustomElement$1m, alertController$1);\nconst actionSheetController = /*@__PURE__*/createController(defineCustomElement$1l, actionSheetController$1);\nconst loadingController = /*@__PURE__*/createController(defineCustomElement$1n, loadingController$1);\n/**\n * @deprecated Use the inline ion-picker component instead.\n */\nconst pickerController = /*@__PURE__*/createController(defineCustomElement$1p, pickerController$1);\nconst toastController = /*@__PURE__*/createController(defineCustomElement$1r, toastController$1);\nexport { IonAccordion, IonAccordionGroup, IonActionSheet, IonAlert, IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonBreadcrumb, IonBreadcrumbs, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonDatetimeButton, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonInputOtp, IonInputPasswordToggle, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonLoading, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNavLink, IonNote, IonPage, IonPicker, IonPickerColumn, IonPickerColumnOption, IonPickerLegacy, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSegmentContent, IonSegmentView, IonSelect, IonSelectModal, IonSelectOption, IonSkeletonText, IonSpinner, IonSplitPane, IonTab, IonTabBar, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToast, IonToggle, IonToolbar, IonicVue, actionSheetController, alertController, loadingController, modalController, onIonViewDidEnter, onIonViewDidLeave, onIonViewWillEnter, onIonViewWillLeave, pickerController, popoverController, toastController, useBackButton, useIonRouter, useKeyboard };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}